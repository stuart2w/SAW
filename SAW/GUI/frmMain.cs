using System.Collections.Generic;
using System;
using System.ComponentModel;
using System.Drawing;
using System.Diagnostics;
using System.Drawing.Text;
using System.Windows.Forms;
using System.IO;
using System.Linq;
using System.Text;
using Resources;
using SAW.Functions;
using Action = SAW.Functions.Action;
using SAW.Shapes;

namespace SAW
{
	internal sealed partial class frmMain : KeyForm, IParameterConsumer, IKeyControl
	{

		private bool m_Filling = false;
		private Document m_Document;

		// ReSharper disable InconsistentNaming
		/// <summary>having trouble in the designer (devenv just crashes completely) if this is on the form at design time </summary>
		internal EditableView pnlView;
		// ReSharper restore InconsistentNaming

		/// <summary>list of controls (probably buttons) which trigger verbs and need to be enabled/disabled
		/// every time the selection changes.  Menus are not included in here, because they are disabled as the menu header is opened</summary>
		private readonly List<Control> m_VerbButtons = new List<Control>();

		private Document m_WorksheetPromptDocument = null; // the document containing the getting started information when creating a worksheet. only loaded as needed
		private readonly Timer m_tmrCaret;

		public frmMain()
		{
			try
			{
				m_CodeMovingWindow = true; // to prevent any sizing events doing anything
				Load += frmMain_Load;
				// having trouble in devenv if view appears on form at design time
				pnlView = new EditableView { AutoScroll = false, BackColor = Color.White, Dock = DockStyle.Fill, Name = "pnlView" };
				pnlView.DisplayContextMenu += pnlView_DisplayContextMenu;
				pnlView.StyleStateChanged += StyleStateChanged;
				pnlView.DisplayedAreaChanged += pnlView_DisplayedAreaChanged;
				pnlView.AngleSnapDisplaysMoveChanged += pnlView_AngleSnapDisplaysMoveChanged;
				pnlView.DisplayShapeInfo += pnlView_DisplayShapeInfo;
				pnlView.DisplayMousePosition += pnlView_DisplayMousePosition;
				pnlView.ChangeDiagnostic += s => pnlView_ChangeDiagnostic(s);
				pnlView.DisplayShapeStyles += DisplayShapeStyles;
				pnlView.ApplyDefaultStyles += ApplyDefaultStyles;
				pnlView.RequestPaletteExclusion += SetPaletteExclusionArea;
				var selectedPulse = new EditableView.SelectedPulseProxy(pnlView, this);
				AnimationColourChange.CreateStart(selectedPulse, Shape.HIGHLIGHTCOLOUR2, 6, AnimationController.INFINITEREPETITIONS);

				Controls.Add(pnlView);
				m_Filling = true;

				InitializeComponent();
				ContextMenuTools.InitialiseMenu(mnuTop); // must be before translation, but it can use the text (pre-translation) to determine what the menu does
				ContextMenuTools.InitialiseMenu(ctxBackground);
				Globals.Root.CurrentDocumentChanged += CurrentDocumentChangedExternally;
				Globals.RequestClose += Engine_RequestClose;
				Globals.SettingsChanged += ApplyConfiguration;
				Globals.VerbApplicabilityChanged += Globals_VerbApplicabilityChanged;
				Globals.InvalidCurrentDocument += InvalidDocument;
				Globals.InvalidCurrentState += InvalidState;
				mnuUpdate.Click += Menus.mnuUpdate_Click; // usually on a help menu generated by Menus, but current squatting on file as Help isn't shown
				mnuGraphicsMode.Click += mnuGraphicsMode_Click;
				Palette.DefaultTooltip = ttMain;

				m_tmrCaret = new Timer() { Interval = 1000, Enabled = true };
				m_tmrCaret.Tick += m_tmrCaret_Tick;
				m_Filling = false;

				this.KeyPreview = true;
				SetDefaultStyles(true);

				BuildPalettes();

				ctrPromptArea.AttachedView = pnlView;
				MouseStep.SetMouseStep(AppliedConfig.MouseSteps.Small);
				ActualChangeSnapMode(Shape.SnapModes.Off);

				m_LineStyleDefault.SetDefaults();
				m_FillStyleDefault.SetDefaults();
				m_TextStyleDefault.SetDefaults();
			}
			catch (Exception ex) when (!Globals.Root.IsDebug)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				m_CodeMovingWindow = false;
			}
		}


		// Debug bits in here...
		public void frmMain_Load(object sender, EventArgs e)
		{
			try
			{
				MouseUp += frmMain_MouseUp;
				MouseDown += frmMain_MouseDown;
				MouseMove += frmMain_MouseMove;
				Move += frmMain_Move;
				FormClosing += frmMain_FormClosing;
				FormClosed += frmMain_FormClosed;
				GotFocus += frmMain_GotFocus;
				LostFocus += frmMain_LostFocus;
				VisibleChanged += frmMain_VisibleChanged;

				Strings.Translate(mnuTop);
				Strings.Translate(ctxPalette);
				Strings.Translate(ctxBackground);
				ttMain.SetToolTip(btnPagePrevious, Strings.Item("Verb_PagePrevious"));

				this.Resize += frmMain_Resize;
				this.MouseCaptureChanged += frmMain_MouseCaptureChanged;

				mnuTop.Items.Insert(mnuTop.Items.Count - 1, Menus.CreateHelpMenu()); // Must be inserted before the support menu
				Menus.PopulateSupportMenu(mnuSupport);
				CreateContextMenus();
				pnlToolbar.WrapContents = false; // tends to make matching the window to the requested client area tricky

#if DEBUG
				mnuSupport.Visible = true;
				mnuSystemConfig.Visible = true;
				mnuActivityConfig.Visible = true;
				mnuActivityConfigUser.Visible = true;

				// items on support menu
				mnuDisplayDiagnostic.Visible = true;
				mnuDiagnosticDivider.Visible = true;

				pnlConstruction.Visible = false;

				pnlView.ChangeZoom(Globals.Root.CurrentConfig.DefaultZoom());

#endif
			}
			catch (Exception ex) when (!Globals.Root.IsDebug)
			{
				MessageBox.Show(ex.ToString());
			}
		}

		#region Document and screen

		private bool m_Displayed;
		public void Display()
		{
			// other things like AM.User are already set.  Called whenever the editor is being displayed from the menu
			// DocumentChanged will have already been triggered from the event.  This tidies up a few other bits and pieces
			Debug.Assert(m_Document == Globals.Root.CurrentDocument);
			if (m_Document == null)
				throw new NullReferenceException("frmMain.Display with null document");
			Globals.SendDelayedEvents(this, null); // not sure why this was removed (after 2.05.3 and before first attempt at 2.06) - but it causes a lot of flicker as the screen is opened if activity differs
			Application.DoEvents();
			string toolsID = Globals.Root.CurrentConfig.PaletteSelection(new Palette.Purpose(Parameters.Tool), false);
			Palette.Item("DocumentOutline").Position.Dock = DockStyle.None;
			Palette.Item(toolsID).Position.Dock = DockStyle.None;
			// but doing that means they are using the position bounds which may have a largely undefined size.  It's too complicated to set it to match the controls, so just use a sensible size:
			Palette.Item("DocumentOutline").Position.Bounds.Size = new Size(200, 500);
			if (!Activities.IsGraphicsMode)
				Palette.Item(toolsID).Position.Bounds.Size = new Size(150, 300); // note A:R will be adjusted later to match definition, keeping diagonal length the same, so X or Y could change if A:R wrong here
			Show();
			RebuildDocking();
			m_Displayed = true;
			MatchWindowToSet();
			Palette.Item("DocumentOutline").Position.MoveBesideForm(this, false);
			Palette.Item(Parameters.Tool).Position.MoveBesideForm(this, true);
			RebuildDocking();
		}

		private void DisposeApplication()
		{
		}

		internal bool IsDocumentSequence
		{ get { return false; } }

		private void CurrentDocumentChangedExternally()
		{
			// ie user has changed tab.  AM.* (eg config) already set (but config changed event will fire on delay later)
			if (IsDisposed)
				return;
			try
			{
				m_Document = Globals.Root.CurrentDocument;
				if (m_Document == null)
				{
					if (Visible)
						Hide(); // just in case this has been collapsed somehow and the user got back to the menu screen with this floating around (happens in editing)
					pnlView.DisplayPage(null, m_Document);
					return;
				}
				m_Document.GetCreateUserSettings(); // because not protected in some other places
				m_Document.GetCreateBothSettings();
				// Settings change has already been triggered by the assignment of the global document - but will actually fire after this
				ctrPageList.Document = m_Document; // doesn't do any harm to set this too often
				DisplayPage(0, true);
				ActualChangeSnapMode(m_Document.SnapMode);
				EnableGridSnap();
				pnlView.ChangeZoom(m_Document.IsPaletteWithin ? 2 : Globals.Root.CurrentConfig.DefaultZoom()); // Palettes always start double size.  Can't double config value as it may be -ve
																											   // must be after ApplyConfiguration; otherwise AM.CurrentConfig has not been updated
				Lined.WireFrame = false;
				ctrDocuments.DocumentsChanged();
				if (!ctrDocuments.Visible)
					SetDefaultStyles(false);

				// SettingsChanged event will trigger the settings rebuild
				GC.Collect();
				if (m_Displayed)
					MatchWindowToSet();
			}
			catch when (!Globals.Root.IsDebug)
			{
				if (m_Document == null || m_Document.IsDisposed || m_Page == null || m_Page.IsDisposed)
				{
					Globals.Root.Log.WriteLine("Editor form self-disposing due to invalid state in DocumentChangedExternally");
					Dispose();
				}
				throw;
			}
		}

		#endregion

		#region Whole screen things

		public void LeavingScreen()
		{
			// called by AM when leaving this screen - either to quit app or revert to menu
			Config.UserUser.StorePalettePositions();
			pnlView.EndDisplayPage();
		}

		protected override void Dispose(bool disposing)
		{
			// must define this otherwise designer would create an auto one which disposes document (which crashes if editing a palette - which is saved on exit, after disposal)
			try
			{
				if (disposing)
				{
					try
					{
						Globals.StoreEvent("frmMain.Dispose");
					}
					catch
					{
					}
					components?.Dispose();
					m_WorksheetPromptDocument?.Dispose();
					m_WorksheetPromptDocument = null;
					m_tmrCaret?.Dispose();
					m_pnlArrowheads?.Dispose();
					m_pnlArrowheads = null;
					m_pnlDocumentOutline?.Dispose();
					m_pnlDocumentOutline = null;
					DisposeApplication();
					m_Document = null;
					m_Page = null;
				}
				Globals.Root.CurrentDocumentChanged -= CurrentDocumentChangedExternally;
				Globals.RequestClose -= Engine_RequestClose;
				Globals.SettingsChanged -= ApplyConfiguration;
				Globals.VerbApplicabilityChanged -= Globals_VerbApplicabilityChanged;

				Globals.InvalidCurrentDocument -= InvalidDocument;
				Globals.InvalidCurrentState -= InvalidState;
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		private void m_tmrCaret_Tick(object sender, EventArgs e)
		{
			Shape.CaretAnimate();
		}

		public void frmMain_VisibleChanged(object sender, EventArgs e)
		{
			if (Visible == false)
				HidePaletteForms();
		}


		#endregion

		#region Window sizing to match set and vice versa

		/// <summary>True if the code is adjusting the window (if false, and the user is doing so, this is used to update the data)</summary>
		private bool m_CodeMovingWindow;

		private Transaction m_WindowMoveTransaction;

		internal void MatchWindowToSet()
		{
			if (m_Document == null || Globals.Root.CurrentPage == null || m_Document.SAWHeader == null)
				return;
			m_CodeMovingWindow = true;
			Rectangle doc = m_Document.SAWHeader.GetAdjustedWindowBounds();
			if (!doc.IsEmpty)
			{
				for (int attempt = 1; attempt < 5 && !doc.Size.Equals(pnlView.Size); attempt++)
				{ // might need more than one try, sinze adjusting the screen size might make other controls resize (eg tool panel switch to 2 columns)
					Rectangle outer = new Rectangle(doc.Left - pnlView.Left,
						doc.Top - pnlView.Top,
						doc.Width + (ClientSize.Width - pnlView.Width),
						doc.Height + (ClientSize.Height - pnlView.Height));
					//Debug.WriteLine("Match; doc=" + doc + ", with pagesize=" + pageSize + ", ClientSize=" + ClientSize + " and pnlView bounds=" + pnlView.Bounds + ", giving window bounds=" + outer);
					//Bounds = outer;
					GUIUtilities.SetFormClientBounds(this, outer);
					//Debug.WriteLine("Final control positions:");
					//foreach (Control c in Controls)
					//	Debug.WriteLine(c.Name + " @ local=" + c.Bounds + ", screen=" + this.RectangleToScreen(c.Bounds));
				}
			}
			else
			{ // old position not recorded, just set size
				Size pageSize = Globals.Root.CurrentPage.Size.ToSize();
				Size size = new Size(pageSize.Width + (ClientSize.Width - pnlView.Width), pageSize.Height + (ClientSize.Height - pnlView.Height));
				//Debug.WriteLine("Match without location; doc=" + doc + ", with pagesize=" + pageSize + ", giving window size=" + size);
				this.ClientSize = size;
			}
			m_CodeMovingWindow = false;
			//Debug.WriteLine($"Outer screen={Bounds}, Client={RectangleToScreen(ClientRectangle)}, pnlView={RectangleToScreen(pnlView.Bounds)}");
		}

		private void frmMain_Move(object sender, EventArgs e)
		{
			//Debug.WriteLine("Main moved to Bounds=" + Bounds + ", view=" + pnlView.Bounds);
			if (m_CodeMovingWindow || m_Document.IsPaletteWithin)
				return;
			m_WindowMoveTransaction?.Cancel();
			Rectangle screenBounds = RectangleToScreen(pnlView.Bounds);
			m_WindowMoveTransaction = frmEditBounds.SetBoundsInData(screenBounds, false);
		}

		private void frmMain_Resize(object sender, EventArgs e)
		{
			if (m_CodeMovingWindow || m_Document.IsPaletteWithin)
				return;
			if (!Globals.Root.CurrentConfig.ReadBoolean(Config.Resize_Document_ToWindow, true))
				return;
			m_WindowMoveTransaction?.Cancel();
			Rectangle screenBounds = RectangleToScreen(pnlView.Bounds);
			bool adjustContents = (ModifierKeys & Keys.Control) > 0 || m_Page.LockARToBackgroundImage;
			m_WindowMoveTransaction = frmEditBounds.SetBoundsInData(screenBounds, adjustContents);
		}

		private void frmMain_MouseCaptureChanged(object sender, EventArgs e)
		{
			if (!Capture && m_WindowMoveTransaction != null)
			{ // must have ended moving
				Globals.Root.StoreNewTransaction(m_WindowMoveTransaction);
				m_WindowMoveTransaction = null;
			}
		}

		#endregion

		#region Construct and control palettes

		// see also RebuildDocking in changing user/config section
		/// <summary>the docking areas created</summary>
		private readonly Dictionary<int, AccordionContainer> m_Accordions = new Dictionary<int, AccordionContainer>();

		private ctrArrowheadsPalette m_pnlArrowheads;
		private ctrDocumentOutline m_pnlDocumentOutline;

		/// <summary>Indexed by purpose.  Therefore there may be one for each defined purpose, and every custom palette may appear</summary>
		private readonly Dictionary<Palette.Purpose, Palette> m_DisplayedPalettes = new Dictionary<Palette.Purpose, Palette>();

		private void BuildPalettes()
		{
			// This is divided into some sub functions just to keep the length sane
			// Only constructs the standard palettes.  User defined, custom ones (including any standard ones defined this way) are added later
			Debug.Assert(Palette.List.Count == 0, "Clearing palettes.  Should only happen when reopening main screen for text change");
			Palette.List.Clear();
			BuildUserPalettes();
			BuildAdvancedPalettes();
		}

		private ctrCoordEdit m_CoordEdit;
		private void BuildUserPalettes()
		{
			ColourPanel pnlLineColour = new ColourPanel() { Blend = ButtonPanel.BlendDirection.Down, DisplayAdvanced = true, Size = new Size(221, 86) };
			pnlLineColour.AttachParameter(Parameters.LineColour);
			pnlLineColour.SetStandard18Colours();
			Palette.Register(new Palette(Parameters.LineColour, pnlLineColour, "[Palette_LineColour]", "LineColour"));

			ColourPanel pnlFillColour = new ColourPanel() { Blend = ButtonPanel.BlendDirection.Down, DisplayAdvanced = true, Size = new Size(221, 93), VariableValue = 100 };
			pnlFillColour.SetStandard18Colours();
			pnlFillColour.AttachParameter(Parameters.FillColour);
			Palette.Register(new Palette(Parameters.FillColour, pnlFillColour, "[Palette_FillColour]", "FillColour"));

			ctrTextStyle pnlTextStyle = new ctrTextStyle();
			pnlTextStyle.Size = new Size(200, 69);
			pnlTextStyle.Initialise(); // creates the buttons etc, attaches params
			Palette.Register(new Palette(Parameters.FontSize, pnlTextStyle, "[Palette_TextStyle]", "TextStyle"));

			Palette.Register(new Palette("Rotation", Palette.Purpose.Specials.Rotation, new ctrRotation(), "[Palette_Rotation]", "Rotation"));
			Palette.Register(new Palette("CoordEdit", Palette.Purpose.Specials.CoordEdit, m_CoordEdit = new ctrCoordEdit(), "[Palette_CoordEdit]", "CoordEdit"));
			Palette.Register(new Palette("Scale", Palette.Purpose.Specials.Scale, new ctrScale(), "[Palette_ShowScale]", "Scale"));
		}

		/// <summary>Ensures that the palette is expanded if it is docked, and optionally gives it focus</summary>
		internal void TriggerPalette(Palette.Purpose purpose, bool giveFocus, bool noWarningIfNotDisplayed = false)
		{
			// focus only transferred here from main drawing area if specifically needed (ie user pressed key short cut for this palette)
			// this can also be used whenever we want to automatically make sure a palette is visible, and we DONT want the focus to jump all by itself
			if (purpose.IsParameter && purpose.Parameter == Parameters.Tool)
			{
				// special case - this can be triggered, but isn't actually a standard palette
				if (!pnlTools.Visible)
					return;
				if (giveFocus)
					pnlTools.Focus();
				return;
			}
			if (!m_DisplayedPalettes.ContainsKey(purpose))
			{
				if (!noWarningIfNotDisplayed)
					Utilities.LogSubError("Triggering non-displayed palette: " + purpose);
				return;
			}
			Palette palette = m_DisplayedPalettes[purpose];
			if (palette.Position.Dock != DockStyle.None)
				palette.Accordion?.Trigger();
			else
				palette.Form?.BringToFront();
			if (giveFocus)
			{
				palette.Control.Focus();
				((IPalette)palette.Control).BringPointerInsideOnActivation();
			}
		}

		internal void BringPaletteWindowToFront(frmPalette frm)
		{
			// calling Form.BringToFront gives a form the focus.  Can't use MDI because those forms go behind this form controls (and anyway they can't leave this
			// form - which is the whole point of usign subforms)
			Windows.SetWindowPos(frm.Handle, Windows.HWND_TOP, 0, 0, 0, 0, Windows.SWP_NOSIZE | Windows.SWP_NOMOVE | Windows.SWP_NOACTIVATE);
		}

		/// <summary>finds the palette given either the accordion or form. (Or the control itself) </summary>
		private Palette FindPalette(Control ctr)
		{
			return Palette.List.Values.FirstOrDefault(palette => palette.Accordion == ctr || palette.Form == ctr || palette.Control == ctr);
		}

		private void BuildAdvancedPalettes()
		{
			m_pnlArrowheads = new ctrArrowheadsPalette();
			m_pnlArrowheads.pnlArrowheads.SelectedIndex = 1;
			m_pnlArrowheads.pnlArrowheadEndStyle.ButtonSize = (int)(m_pnlArrowheads.pnlArrowheadEndStyle.ButtonSize * GUIUtilities.SystemDPIRelative);
			foreach (int i in ParameterSupport.GetStandardParameterValues(Parameters.ArrowheadEndType))
			{
				Lined.ArrowheadC.Styles type = (Lined.ArrowheadC.Styles)i;
				ArrowheadButton button;
				if (type != Lined.ArrowheadC.Styles.Fletching)
				{
					button = m_pnlArrowheads.pnlArrowheadEndStyle.AddArrowheadButton();
					button.AttachParameter(Parameters.ArrowheadEndType, i);
				}
				if (type != Lined.ArrowheadC.Styles.LongSolid)
				{
					button = m_pnlArrowheads.pnlArrowheadStartStyle.AddArrowheadButton();
					button.AttachParameter(Parameters.ArrowheadStartType, i);
				}
			}
			foreach (int size in ParameterSupport.GetStandardParameterValues(Parameters.ArrowheadEndSize))
			{
				ArrowheadButton button = m_pnlArrowheads.pnlArrowheadEndSize.AddArrowheadButton();
				button.AttachParameter(Parameters.ArrowheadEndSize, size);
				button = m_pnlArrowheads.pnlArrowheadStartSize.AddArrowheadButton();
				button.AttachParameter(Parameters.ArrowheadStartSize, size);
			}
			Palette.Register(new Palette(Parameters.ArrowheadEndType, m_pnlArrowheads, "[Palette_Arrowheads]", "Arrowheads"));

			// *** when converting these to custom documents add the image names in PalettePurpose

			m_pnlDocumentOutline = new ctrDocumentOutline();
			Palette.Register(new Palette("DocumentOutline", Palette.Purpose.Specials.DocumentOutline, m_pnlDocumentOutline, "[Document_Outline]", "DocumentOutline_24"));
			m_pnlDocumentOutline.RequestSelectPage += (sender, page) => { DisplayPage(m_Document.IndexOf(page)); };
		}

		#endregion

		#region Moving palettes

		internal Palette MovingPalette;
		private Size m_PaletteOffset; // offset of the top left of the palette from the mouse coordinate (palette forms need to apply a further offset to get the actual form edge)
		private PalettePosition m_MovingPosition = new PalettePosition(); // current position if dropped where mouse is now
		private TargetControl m_PaletteTarget; // hidden but not disposed as needed

		internal void StartAccordionMove(Accordion accordion, Size offset)
		{
			// szOffset is the location of the control relative to the mouse when the movement starts
			m_PaletteOffset = offset;
			MovingPalette = FindPalette(accordion);
			EnsurePaletteForm(MovingPalette);
			if (MovingPalette.Preview == null)
				MovingPalette.Preview = GUIUtilities.ImageOfControl(MovingPalette.Control);
			MovingPalette.Form.ControlLocation = Cursor.Position + offset;
			MovingPalette.Form.UpdateSize();
			MovingPalette.Form.Opacity = 0.25;
			MovingPalette.Form.Show();
			StartPaletteMoveShared();
			this.Focus(); // new form tends to get the focus
		}

		private void EnsurePaletteForm(Palette palette)
		{
			// ensures that the form for the given palette is created
			if (palette.Form != null) return;
			palette.Form = new frmPalette(palette)
			{
				Owner = this,
				ControlLocation = PointToScreen(palette.Position.Bounds.Location) // sets X Y but not width
			};
		}

		internal void StartPaletteFormMove(Palette palette, Size offset)
		{
			// szOffset is the location of the control relative to the mouse when the movement starts
			// no need for preview - form has the control
			m_PaletteOffset = offset;
			MovingPalette = palette;
			MovingPalette.Form.Opacity = 0.8;
			StartPaletteMoveShared();
		}

		private void StartPaletteMoveShared()
		{
			pnlView.Focus();
			GUIUtilities.CurrentFocus = this; // Both needed so that navigation keys work correctly
			Capture = true;
			if (m_PaletteTarget == null)
			{
				m_PaletteTarget = new TargetControl(); // starts invisible
				this.Controls.Add(m_PaletteTarget);
				m_PaletteTarget.BringToFront();
			}
		}

		private const int NEWCONTAINERZONE = 20;
		private const int PALETTETARGETV = 20; // size of target indicator if vertical
		private const int PALETTETARGETH = 20; // size of target indicator

		private void FloatPalette(int X, int Y)
		{
			Point local = new Point(X, Y);
			Point screen = this.PointToScreen(local);
			MovingPalette.Form.ControlLocation = screen + m_PaletteOffset;
			m_MovingPosition.Dock = DockStyle.None; // will be changed if we find a dock position below
			foreach (AccordionContainer container in m_Accordions.Values)
			{
				if (container.Bounds.Contains(local))
				{
					// will drop inside unless near edges, which makes new container
					Debug.Assert(container.Dock == DockStyle.Left || container.Dock == DockStyle.Right); // they only support L and R at the mo
					int direction = 0; // relative to this one
					if (local.X <= container.Bounds.X + NEWCONTAINERZONE)
						direction = -1;
					if (local.X >= container.Bounds.Right - NEWCONTAINERZONE)
						direction = 1; // intDirection now relative DockLevel for RHS
					if (container.Dock == DockStyle.Left)
						direction = -direction;
					// but we won't create a new container between 2 existing ones (too much effort to reassign all the DockLevels of the existing stuff and I can't see anyone
					// really having 3 columns)...
					if (direction != 0 && m_Accordions.ContainsKey(PalettePosition.CalculateAccordionKey(container.Dock, container.DockLevel + direction)))
						direction = 0;
					m_MovingPosition.Dock = container.Dock;
					m_MovingPosition.DockLevel = container.DockLevel + direction;
					if (direction != 0)
					{
						m_MovingPosition.DockIndex = 0; // will be first item
						m_MovingPosition.Bounds = new Rectangle(container.Left - PALETTETARGETV / 2, container.Top, PALETTETARGETV, container.Height);
						if (direction == 1 && container.Dock == DockStyle.Right || direction == -1 && container.Dock == DockStyle.Left)
							m_MovingPosition.Bounds.X += container.Width;
						if (m_MovingPosition.Bounds.Right > ClientSize.Width)
							m_MovingPosition.Bounds.X -= m_MovingPosition.Bounds.Right - ClientSize.Width;
					}
					else
					{
						// need to find location within accordion.  Index stored is the one it comes after
						int controlIndex = container.FindInsertIndex(local.Y - container.Top);
						int controlY = 0;
						if (controlIndex > 0)
						{
							controlY = container.Controls[controlIndex - 1].Bottom;
							m_MovingPosition.DockIndex = ((Accordion)container.Controls[controlIndex - 1]).Palette.Position.DockIndex + 1;
						}
						else // intControlY remains 0
							m_MovingPosition.DockIndex = ((Accordion)container.Controls[0]).Palette.Position.DockIndex;
						m_MovingPosition.Bounds = new Rectangle(container.Left, container.Top + controlY - PALETTETARGETH / 2, container.Width, PALETTETARGETH);
					}
				}
			}

			// that has detected hits inside any existing accordion.  Now look for edge of screen
			// (if accordions on that edge this is largely redundant, but doesn't matter)
			if (m_MovingPosition.Dock == DockStyle.None && local.Y >= 0 && local.Y <= Height)
			{
				if (Math.Abs(local.X) < NEWCONTAINERZONE)
					SetPaletteTargetEdge(DockStyle.Left);
				else if (Math.Abs(local.X - Width) < NEWCONTAINERZONE)
					SetPaletteTargetEdge(DockStyle.Right);
			}

			if (m_MovingPosition.Dock == DockStyle.None)
			{
				// form already positioned
				m_PaletteTarget.Visible = false; // no dock target needed
				MovingPalette.Form.Opacity = 0.8;
				m_MovingPosition.Bounds = RectangleToClient(MovingPalette.Form.ControlBounds);
			}
			else if (m_MovingPosition.Dock == MovingPalette.Position.Dock && m_MovingPosition.DockLevel == MovingPalette.Position.DockLevel &&
					 (m_MovingPosition.DockIndex == MovingPalette.Position.DockIndex || m_MovingPosition.DockIndex == MovingPalette.Position.DockIndex - 1))
			{
				// it's back in its original position
				MovingPalette.Form.Opacity = 0.25;
				m_PaletteTarget.Visible = false;
			}
			else
			{
				m_PaletteTarget.Visible = true;
				MovingPalette.Form.Opacity = 0.25;
				m_PaletteTarget.Bounds = m_MovingPosition.Bounds;
				m_PaletteTarget.Refresh();
				m_PaletteTarget.BringToFront();
			}
		}

		/// <summary> moving palette would go into a new accordion on the given edge find highest existing DockLevel on that edge </summary>
		private void SetPaletteTargetEdge(DockStyle dock)
		{
			int level = 0;
			foreach (AccordionContainer container in m_Accordions.Values)
			{
				if (container.Dock == dock)
					level = Math.Max(level, container.DockLevel + 1);
			}
			m_MovingPosition.Dock = dock;
			m_MovingPosition.DockLevel = level;
			m_MovingPosition.DockIndex = 0; // new container
			m_MovingPosition.Bounds = new Rectangle(0, 0, PALETTETARGETV, Height);
			if (dock == DockStyle.Right)
				m_MovingPosition.Bounds.X = ClientSize.Width - PALETTETARGETV;
		}

		internal void CompletePaletteMove()
		{
			// m_MovingPosition should already be set
			m_PaletteTarget.Visible = false;
			Cursor.Current = Cursors.Default; // can be changed for various reasons were moving
			if (MovingPalette == null)
				return;
			if (m_MovingPosition.Dock == DockStyle.None)
			{
				// as form
				MovingPalette.Form.GainControl(); // adds the control if it doesn't already have it
				if (MovingPalette.Position.Dock != DockStyle.None)
				{
					AccordionContainer container = (AccordionContainer)MovingPalette.Accordion.Parent;
					container.Controls.Remove(MovingPalette.Accordion);
					MovingPalette.Accordion.Controls.Clear();
					// should not still contain the control (GainControl above will have removed it), but just in case
					// still having an occasional crash due to stray palette
					MovingPalette.Accordion.Dispose();
					MovingPalette.Accordion = null;
					if (container.Controls.Count == 0)
					{
						m_Accordions.Remove(container.Key);
						container.Dispose();
					}
				}
				MovingPalette.Position.CopyFrom(m_MovingPosition);
				MovingPalette.Form.Focus();
			}
			else
			{
				// docked in accordion.  First check if another has same position
				Palette existing = Palette.FindDockedAt(m_MovingPosition.Dock, m_MovingPosition.DockLevel, m_MovingPosition.DockIndex);
				if (existing != MovingPalette) //else have put back  in same place - most of the rest can be skipped
				{
					if (existing != null)
					{
						// collides - must increase indices of all existing ones
						foreach (Palette palette in Palette.List.Values)
						{
							if (palette.Position.Dock == m_MovingPosition.Dock && palette.Position.DockLevel == m_MovingPosition.DockLevel &&
								palette.Position.DockIndex >= m_MovingPosition.DockIndex)
							{
								palette.Position.DockIndex += 1;
							}
						}
					}
					int width = MovingPalette.Position.Bounds.Width; // need to keep this because the width in m_MovingPosition may have been corrupted to use the location of a drop target
					MovingPalette.Position.CopyFrom(m_MovingPosition);
					MovingPalette.Position.Bounds.Width = width;
					if (MovingPalette.Accordion != null)
						MovingPalette.Accordion.LastAccessed = DateTime.Now; // Ensure that this one is not collapsed within the accordion container
					RebuildDocking(); // just rebuild the lot - easiest
									  // There are edge cases were According might not be defined.  (In particular if it's not actually displayed by RebuildDocking)
					if (MovingPalette.Accordion != null)
						MovingPalette.Position.Bounds.Width = MovingPalette.Accordion.Width - AccordionContainer.RESIZEWIDTH;
				}
			}
			if (MovingPalette != null)
			{
				MovingPalette.Form.Visible = m_MovingPosition.Dock == DockStyle.None;
				MovingPalette.Form.Opacity = 1;
			}
			MovingPalette = null;
		}

		internal void AbortPaletteMove()
		{
			m_PaletteTarget.Visible = false;
			if (MovingPalette == null)
				return;
			MovingPalette.Form.Visible = MovingPalette.Position.Dock == DockStyle.None;
			MovingPalette.Form.Opacity = 1;
			MovingPalette = null;
			RebuildDocking();
			Cursor.Current = Cursors.Default;
			// can be changed for various reasons were moving
			// original control should still be in place
		}

		private void frmMain_MouseUp(object sender, MouseEventArgs e)
		{
			if (MovingPalette != null)
			{
				FloatPalette(e.X, e.Y);
				CompletePaletteMove();
			}
		}

		private void frmMain_MouseDown(object sender, MouseEventArgs e)
		{
			// right button cancels a palette move
			if (e.Button == MouseButtons.Right && MovingPalette != null)
				AbortPaletteMove();
		}

		private void frmMain_MouseMove(object sender, MouseEventArgs e)
		{
			if (MovingPalette != null)
				FloatPalette(e.X, e.Y);
		}

		#region Class TargetControl: Palette drop target indicator

		private sealed class TargetControl : Control
		{
			public TargetControl()
			{
				Visible = false;
				Font = new Font(FontFamily.GenericSansSerif, 10, FontStyle.Bold);
				DoubleBuffered = !Utilities.Low_Graphics_Safe();
				BackColor = Color.White;
			}

			protected override void OnPaint(PaintEventArgs e)
			{
				//MyBase.OnPaint(e)
				if (!Utilities.Low_Graphics_Safe())
					e.Graphics.TextRenderingHint = TextRenderingHint.AntiAlias;
				if (this.Width > PALETTETARGETH && this.Height == PALETTETARGETH)
				{
					// is horizontal
					e.Graphics.DrawString(Strings.Item("Palette_Drop"), Font, Brushes.Black, new Rectangle(0, 0, Width, Height), GUIUtilities.StringFormatCentreCentre);
				}
				else if (this.Width == PALETTETARGETV && this.Height > PALETTETARGETV)
				{
					e.Graphics.RotateTransform(90);
					e.Graphics.DrawString(Strings.Item("Palette_Drop_New_Column"), Font, Brushes.Black, new Rectangle(0, -Width, Height, Width), GUIUtilities.StringFormatCentreCentre);
					// Height, Width look daft because rotated - it is correct
				}
			}

			protected override void OnClick(EventArgs e)
			{
				Utilities.LogSubError("TargetControl clicked");
				this.Hide();
			}
		}

		#endregion

		internal void ResetPalettes()
		{
			foreach (var palette in Palette.List.Values)
			{
				palette.SetDefaultPosition();
			}
			Config.UserCurrent.StorePalettePositions();
			RebuildDocking();
			MessageBox.Show(Strings.Item("Palette_Reset_Done"));
		}

		private void AccordionContainer_ResizeWidthFinished(object sender, EventArgs e)
		{
			AccordionContainer container = (AccordionContainer)sender;
			// accordion itself has changed controls - just store the result
			foreach (Accordion accordion in container.Controls)
			{
				accordion.Palette.Position.Bounds.Width = container.Width - AccordionContainer.RESIZEWIDTH;
			}
		}

		#region Palette header menu

		// displays the menu from right clicking on the palette header
		private Palette m_MenuPalette; // The palette which was targeted for the menu

		internal void ShowPaletteMenu(Control control, Point position, Palette palette)
		{
			mnuPaletteEdit.Visible = Globals.Root.User == Users.Editor && palette.UserDefined;
			mnuPaletteReset.Enabled = true;
			// Scaling menu is only available for flowing custom palettes
			mnuPaletteScale.Visible = palette.Control is PaletteView view && view.IsFlow;
			mnuPaletteSmaller.Visible = palette.Control.Width > 50;
			mnuPaletteLarger.Visible = palette.Control.Width < 350;
			List<Palette> col;
			if (palette.PalettePurpose.IsCustom)
				col = new List<Palette>(); // never show for custom
			else
				col = Globals.Root.CurrentConfig.AvailablePalettesForPurpose(palette.PalettePurpose);
			if (col.Count > 1)
			{
				mnuPaletteChoose.Visible = true;
				mnuPaletteChoose.DropDownItems.Clear();
				foreach (var item in col)
				{
					ToolStripMenuItem mnu = new ToolStripMenuItem(item.EditDescription) { Tag = item };
					mnuPaletteChoose.DropDownItems.Add(mnu);
					mnu.Click += mnuPaletteChooseItem_Click;
					if (item.ID == Globals.Root.CurrentConfig.ReadString(Config.SelectPaletteKey(item.PalettePurpose)))
						mnu.Checked = true;
				}
			}
			else
				mnuPaletteChoose.Visible = false;
			m_MenuPalette = palette;
			ctxPalette.Show(control, position);
		}

		public void mnuPaletteEdit_Click(object sender, EventArgs e)
		{
			Debug.Assert(m_MenuPalette.UserDefined);
			if (!Globals.Root.CurrentConfig.ReadBoolean(Config.Multiple_Documents))
			{
				MessageBox.Show(Strings.Item("Palette_MultiDocumentChanged"));
				Config.UserEditor.Write(Config.Multiple_Documents, true.ToString());
				if (Globals.Root.User == Users.User)
					Globals.Root.User = Users.Editor;
				else
					Globals.OnSettingsChanged();
			}
			Globals.Root.SelectDocument(m_MenuPalette.CustomDocument);
		}

		public void mnuPaletteHide_Click(object sender, EventArgs e)
		{
			Config objSettings;
			if (Globals.Root.User == Users.User)
				objSettings = m_Document.UserSettings;
			else
				objSettings = m_Document.BothSettings;
			Transaction objTransaction = new Transaction();
			objTransaction.Edit(objSettings);
			objSettings.Write(Config.ShowPaletteKey(m_MenuPalette), false.ToString()); // Hides this type of palette in fact
			RebuildDocking();
			if (Strings.OnceMessage("Palette_HiddenMessage"))
				MessageBox.Show(Strings.Item("Palette_HiddenMessage"));
			StoreNewTransaction(objTransaction);
		}

		public void mnuPaletteReset_Click(object sender, EventArgs e)
		{
			m_MenuPalette.SetDefaultPosition();
			RebuildDocking();
		}

		public void mnuPaletteScale_Click(object sender, EventArgs e)
		{
			if (!(m_MenuPalette.Control is PaletteView))
				return;
			int zoom = int.Parse(((ToolStripMenuItem)sender).Text.Trim('%'));
			PaletteView paletteView = (PaletteView)m_MenuPalette.Control;
			float change = zoom / 100f / paletteView.Zoom;
			paletteView.ChangeZoom(zoom / 100f);
			if (m_MenuPalette.Position.Dock == DockStyle.None)
			{
				paletteView.Size = paletteView.SizeFromSize(new SizeF(paletteView.Width * change, paletteView.Height * change).ToSize());
				m_MenuPalette.Form.UpdateSize();
			}
			else
			{
				paletteView.SizeFromWidth(paletteView.Width);
				RebuildDocking(); // does height
			}
		}

		private void mnuPaletteChooseItem_Click(object sender, EventArgs e)
		{
			ToolStripMenuItem mnu = (ToolStripMenuItem)sender;
			if (mnu.Checked)
				return;
			Palette palette = (Palette)mnu.Tag;
			Transaction transaction = new Transaction();
			Config config = m_Document.GetCreateBothSettings(transaction);
			transaction.Edit(config);
			config.Write(Config.SelectPaletteKey(palette.PalettePurpose), palette.ID);
			StoreNewTransaction(transaction);
		}

		public void mnuPaletteLargerSmaller_Click(object sender, EventArgs e)
		{
			var scale = sender == mnuPaletteLarger ? 1.1F : 0.90909F;
			if (m_MenuPalette.Accordion != null)
			{
				var container = m_MenuPalette.Accordion.Parent;
				if (container == null)
					return;
				container.Width = (int)(container.Width * scale);
			}
			else if (m_MenuPalette.Form != null)
				m_MenuPalette.Form.Size = new SizeF(m_MenuPalette.Form.Width * scale, m_MenuPalette.Form.Height * scale).ToSize();
		}

		#endregion

		/// <summary>Update the palette positions, rebuilding the structure needed for docking them, as needed</summary>
		private void RebuildDocking()
		{
			// rebuild accordions and containers - on config change or when docking one
			this.SuspendLayout();
			List<AccordionContainer> containers = new List<AccordionContainer>(); // used to sort them into dock level order
			foreach (AccordionContainer container in m_Accordions.Values)
			{
				container.StartBuild();
				containers.Add(container);
			}
			m_DisplayedPalettes.Clear();
			foreach (Palette palette in Palette.List.Values)
			{
				bool isAccordion = false;
				if (Globals.Root.CurrentConfig.ShowPalette(palette))
				{
					if (m_DisplayedPalettes.ContainsKey(palette.PalettePurpose))
						Debug.Fail("Multiple palettes displayed for purpose: " + palette.PalettePurpose.Name);
					else
						m_DisplayedPalettes.Add(palette.PalettePurpose, palette);
					if (palette.Position.Dock != DockStyle.None)
					{
						isAccordion = true;
						AccordionContainer container;
						if (palette.Position.Bounds.Width < 10)
						{
							// can be 0 if never positioned before by this user.  Set default width.  (Unpositioned ones will always start docked)
							if (palette.UserDefined)
								palette.Position.Bounds.Width = (int)(palette.CustomDocument.Page(0).Size.Width * pnlView.ApproxPixelsPerDocUnit);
							else
								palette.Position.Bounds.Width = 200; // original default width (ish)
						}
						if (m_Accordions.ContainsKey(palette.Position.AccordionKey))
						{
							container = m_Accordions[palette.Position.AccordionKey];
							container.Width = Math.Max(container.Width, palette.Position.Bounds.Width + AccordionContainer.RESIZEWIDTH);
						}
						else
						{
							container = new AccordionContainer
							{ Dock = palette.Position.Dock, DockLevel = palette.Position.DockLevel };
							container.StartBuild(); // Suspends internal layout
							container.Width = Math.Max(100, palette.Position.Bounds.Width + AccordionContainer.RESIZEWIDTH);
							container.Height = 1200;
							// height will ultimately be set by docking; However if left at 0 initially we may end up collapsing all the accordions before it is set
							//objAccordion.Width = objPalette.Position.Bounds.Width + AccordionContainer.RESIZEWIDTH	' height will be set by docking
							// width was stored
							container.AttachEvents();
							this.Controls.Add(container);
							m_Accordions.Add(container.Key, container);
							containers.Add(container);
							container.ResizeWidthFinished += AccordionContainer_ResizeWidthFinished;
						}
						container.AddPalette(palette);

						palette.Form?.Hide();
					}
					else
					{
						// is undocked - form
						EnsurePaletteForm(palette);
						palette.Form.GainControl(); // ignored if already has
						palette.Form.ControlBounds = GUIUtilities.CheckFormRectOnScreen(RectangleToScreen(palette.Position.Bounds));
						if (palette.Form.Visible == false && this.Visible) // latter condition needed to stop this triggering in run mode in SAW
							palette.Form.Visible = true; // in case hidden.  Don't want to do if unnecessary as it focusses the window
					}
					Keys key = Globals.Root.CurrentConfig.GetFirstKeyForAction(palette.PalettePurpose.GetSelectAction());
					palette.ShortcutKey = GUIUtilities.KeyShortDescription(key);
				}
				else
				{
					// is hidden.  Accordion can be ignored any old one will have been lost.
					palette.Form?.Hide();
				}
				if (!isAccordion && palette.Accordion != null)
				{
					// will have been removed if this update was a drag; but may still be attached to anything if this is a change of user
					if (!palette.Accordion.IsDisposed)
					{
						palette.Accordion.Controls.Clear(); // to stop the actual controls being disposed
						palette.Accordion.Dispose();
					}
					palette.Accordion = null;
				}
			}
			this.Focus(); // in case any palette forms shown - which would focus them

			// reposition accordions
			containers.Sort(); // into ascending DockLevel
			foreach (AccordionContainer accordion in containers)
			{
				accordion.Visible = accordion.Count > 0;
				accordion.SendToBack();
			}
			// a few controls need to be docked outside the accordions...
			mnuTop.SendToBack();
			ctrDocuments.SendToBack();
#if DEBUG
			pnlConstruction.SendToBack();
#endif
			this.ResumeLayout();
			// another pass now that this screen has been laid out - letting the accordions do their stuff
			List<AccordionContainer> remove = new List<AccordionContainer>();
			foreach (AccordionContainer container in containers)
			{
				container.EndBuild();
				if (container.Count == 0)
				{
					remove.Add(container);
				}
			}
			foreach (AccordionContainer container in remove)
			{
				this.Controls.Remove(container);
				container.Dispose();
				m_Accordions.Remove(container.Key);
			}
		}

		/// <summary>Palettes may not conflict with this rectangle, in screen coordinates</summary>
		private Rectangle m_PaletteExclusionArea;

		/// <summary>called when document/view specifies an area which must not be covered by palettes (currently for equation codes)
		/// might need to be extended in future to allow multiple areas to be specified - probably meaning each must be tagged either to its owner, or a hash code</summary>
		private void SetPaletteExclusionArea(Rectangle screen)
		{
			if (screen.Equals(m_PaletteExclusionArea))
				return;
			m_PaletteExclusionArea = screen;
			foreach (var palette in m_DisplayedPalettes.Values)
			{
				if (palette.Form != null)
					palette.Form.Visible = Visible && (m_PaletteExclusionArea.IsEmpty || !palette.Form.Bounds.IntersectsWith(m_PaletteExclusionArea));
			}
		}

		#endregion

		#region Changing user, activity, config

		private Users m_LastUser;

		/// <summary>User config for current document, regardless of whether we are in user or teacher mode</summary>
		private AppliedConfig m_UserConfig;

		/// <summary>remember the first one listed so it can be selected</summary>
		private Shape.Shapes m_FirstTool = Shape.Shapes.Selector;

		private void ApplyConfiguration() //(Optional eChangeUser As Users = -1)
		{
			// Called on start-up and if the configuration changes
			// recreate the applied configuration in case configuration objects have been added or removed
			if (m_Document == null || IsDisposed)
				return; // because this will be called again when the document is set
			Globals.StoreEvent("ApplyConfiguration");
			bool oldLowGraphics = Utilities.Low_Graphics_Safe(); // if the graphics quality changes, we need to force everything to refresh
			bool userChanged = m_LastUser != Globals.Root.User;
			m_LastUser = Globals.Root.User;

			try
			{
				ButtonStyle.SetDefaultOnUserChange();
				if (Globals.Root.User == Users.User)
				{
					m_UserConfig = Globals.Root.CurrentConfig;
				}
				else
				{
					m_UserConfig = Globals.Root.GenerateAppliedConfig(Users.User, m_Document);
				}
				// tools...
				this.SuspendLayout();
				List<Shape.Shapes> shapes = FillTools();

				if (pnlTools.Controls.Count == 0)
					pnlTools.Refresh(); // this is needed when changing from user to teacher mode in quick worksheet mode, where the user tools have not been defined
				pnlTools.ResumeLayout();
				SetToolImageSizes();

				// General settings
				UpdateMenuKeys();

				pnlToolbar.SuspendLayout();
				ApplyConfigurationToMiscControls(shapes);
				ApplyConfigurationVisibility();
				Palette.UpdateCustomPalettes(Globals.Root.CurrentConfig);
				if (userChanged)
					Config.UserCurrent.RestorePalettePositions(); // must be after UpdateCustomPalettes but before RebuildDocking
				RebuildDocking();
				CreateToolbarButtons();
				pnlToolbar.ResumeLayout();
				this.ResumeLayout();

				// reset various things
				Shape.EnvironmentChanges change = Shape.EnvironmentChanges.Settings;
				if (userChanged)
					change = change | Shape.EnvironmentChanges.User;
				m_Document?.NotifySettingsChanged(change);
				pnlView.ApplyConfiguration();
				pnlView_DisplayShapeInfo(""); // in case units changed
				Globals.Root.Speech.SettingsChanged(Globals.Root.CurrentConfig);
				SetWindowTitle();
				Globals_VerbApplicabilityChanged();

				if (oldLowGraphics != Globals.Root.CurrentConfig.Low_Graphics)
				{
					pnlToolbar.Refresh();
					pnlLeft.Refresh();
					foreach (Palette palette in Palette.List.Values)
					{
						palette.Control.Refresh();
					}
				}

				if (userChanged && Globals.Root.User == Users.User && (m_Document.InitialLineStyle != null || Config.UserUser.Document.InitialLineStyle != null))
					// if specific default styles are given, they are applied every time we change from teacher to user
					SetDefaultStyles(false);

			}
			catch (Exception ex) when (!Globals.Root.IsDebug)
			{
				frmErrorReport.ReportErrorOnce(frmErrorReport.OnceErrorContexts.frmMain_ApplyConfig, ex);
			}
		}

		private void ApplyConfigurationVisibility()
		{
			// Part of ApplyConfiguration.  Also called when changing between full-screen and not full-screen
			// control/section visibility...

			// if we change the visibility of panels before the screen has been displayed (and this is usually called for the initial document before Load will have finished)
			// it can affect the Z-order of the panels
			// BUT doing this causes the controls to not appear later on the mac
			// ReSharper disable once JoinDeclarationAndInitializer
			// ReSharper disable RedundantAssignment
			// ReSharper disable once NotAccessedVariable
			IntPtr h; // but as long as we ensure that the handles have been assigned it should be OK
#pragma warning disable IDE0059 // Unnecessary assignment of a value
			h = pnlPages.Handle; // http://stackoverflow.com/questions/5766386/how-to-avoid-having-the-z-order-of-controls-changed-when-showing-and-hiding-them
			h = pnlLeft.Handle;
			h = pnlToolbar.Handle;
			// might need to add other panels here if we have problems with anything else
			h = pnlSnap.Handle;
			// ReSharper restore RedundantAssignment

			pnlPages.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_PageList, true);
			// note that pnlPages is automatically hidden if the document is protected and contains only one page (because in this case the user cannot do anything with this panel)
			ctrDocuments.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Multiple_Documents);
			pnlInfo.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_InfoMeasurement, true);
			ctrPromptArea.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_Prompts, true);

			// TB
			pnlLeft.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_Tools, true) && pnlLeft.Controls.Count > 0;
			pnlLeftBorder.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_Tools, true) && pnlLeft.Controls.Count > 0;
			pnlToolbar.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_Toolbar, true);
			pnlSnap.Visible = Globals.Root.CurrentConfig.ShowArea(Config.Show_ToolbarSnap, true);
		}

		/// <summary>Hides all FORMS for palettes; has no effect on docked controls.  Used when main form being hidden</summary>
		private void HidePaletteForms()
		{
			foreach (var palette in m_DisplayedPalettes.Values)
			{
				if (palette.Form != null)
					palette.Form.Hide();
			}
		}

		public void rdoSnapGrid_DoubleClick(object sender, EventArgs e)
		{
			TriggerVerb(Codes.EditPaper, ClickPosition.Sources.Mouse);
		}

		#region Hover prompts

		public void rdoSnapAngle_MouseEnter(object sender, EventArgs e)
		{
			Globals.SetHoverPrompt("Hover_Snap_Angle", "AngleSnap_48", "Hover_Snap_Angle_Explain");
		}

		public void rdoSnapGrid_MouseEnter(object sender, EventArgs e)
		{
			Globals.SetHoverPrompt("Hover_Snap_Grid", "GridSnap_48", "Hover_Snap_Grid_Explain");
		}

		public void rdoSnapShape_MouseEnter(object sender, EventArgs e)
		{
			Globals.SetHoverPrompt("Hover_Snap_Shape", "ShapeSnap_48", "Hover_Snap_Shape_Explain");
		}

		public void rdoUser_MouseLeave(object sender, EventArgs e)
		{
			Globals.ClearHover();
		}

		#endregion

		#region Toolbar buttons and home button

		/// <summary>list of all dynamic buttons included on the toolbar at the top. these will also be included in m_colVerbButtons
		/// this does not include the fixed parts of the toolbar (user mode, grid snapping etc)</summary>
		private List<CustomButton> m_ToolbarButtons = new List<CustomButton>();

		private void CreateToolbarButtons()
		{
			// there is never a divider after the dynamic toolbar buttons.  These are always the last item on the toolbar
			// there should already be a divider before these (each of the other sections included of either after itself)
			int size = Config.Toolbar_ButtonSize_Default;
			List<Codes> verbs = Globals.Root.CurrentConfig.GetToolbarVerbs();
			if (IsDocumentSequence)
				// Open and New are a bit daft when showing a sequence of documents.  They will still appear on the menu, but that's much less prominent
				verbs = verbs.Where(X => X != Codes.Open && X != Codes.NewDocument).ToList();
			if (!Globals.Root.CurrentConfig.ReadBoolean(Config.Show_ToolbarVerbs, true))
				verbs.Clear();
			for (int index = 0; index <= verbs.Count - 1; index++)
			{
				CustomButton button;
				int sizeAdjusted = (int)(size * GUIUtilities.SystemDPIRelative);
				// existing buttons are reused where possible
				if (index < m_ToolbarButtons.Count)
				{
					button = m_ToolbarButtons[index];
					button.Invalidate();
				}
				else
				{
					button = new CustomButton { Text = "", Dock = DockStyle.Left };
					button.Width = sizeAdjusted;
					button.MinimumSize = new Size(button.Width, sizeAdjusted); // only matters if toolbar is only bit shown
					button.Margin = new Padding(3, 4, 0, 4);
					pnlToolbar.Controls.Add(button);
					m_VerbButtons.Add(button);
					m_ToolbarButtons.Add(button);
					button.Click += Verb_Button_Click;
					button.MouseEnter += Verb_Button_Enter;
					button.MouseLeave += Verb_Button_Leave;
				}
				button.Code = verbs[index];
				button.Enabled = VerbApplicable(verbs[index]);
				ttMain.SetToolTip(button, Strings.Item("Verb_" + verbs[index]).Replace("&", ""));
			}
			for (int index = m_ToolbarButtons.Count - 1; index >= verbs.Count; index--)
			{
				// remove any excess buttons
				CustomButton button = m_ToolbarButtons[index];
				m_ToolbarButtons.RemoveAt(index);
				m_VerbButtons.Remove(button);
				pnlToolbar.Controls.Remove(button);
				button.Click -= Verb_Button_Click;
				button.MouseEnter -= Verb_Button_Enter;
				button.MouseLeave -= Verb_Button_Leave;
				button.Dispose();
			}
		}

		#endregion

		private void ApplyConfigurationToMiscControls(List<Shape.Shapes> shapes)
		{
			// Part of ApplyConfiguration
			if (m_Document == null || m_Page == null)
				return; // Much of the stuff below would work, but this will be called again anyway when the document is assigned.  I don't think m_Page should be nothing; there was one apparent error with this, but I think that was caused by the previous error in the document changed which stopped it being assigned
						// note that this ignores the all off option - as it is not a standard part of the screen
			btnPageNext.Enabled = m_PageIndex < m_Document.Count - 1 || !m_Page.IsEmpty;

			// probably worth assigning them in the menu.  The user ones will be automatic as the menu uses the verbs
			mnuSnapOff.ShortcutKeyDisplayString = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Off)));
			mnuSnapGrid.ShortcutKeyDisplayString = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Grid)));
			mnuSnapShape.ShortcutKeyDisplayString = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Shape)));
			mnuSnapAngle.ShortcutKeyDisplayString = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Angle)));
			rdoSnapGrid.ShortcutDisplay = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Grid)));
			rdoSnapShape.ShortcutDisplay = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Shape)));
			rdoSnapAngle.ShortcutDisplay = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(new SnapAction(Shape.SnapModes.Angle)));
			ttMain.Active = Globals.Root.CurrentConfig.ReadBoolean(Config.Tooltips);
			mnuGraphicsMode.Checked = Activities.IsGraphicsMode;

			pnlView.TransformModeChanged();
			mnuDoubleClick.ShortcutKeyDisplayString = GUIUtilities.KeyDescription(Globals.Root.CurrentConfig.GetFirstKeyForAction(Verb.Find(Codes.DoubleClick)));
		}

		internal void SetWindowTitle()
		{
			// this needs to be done on configuration change because it changes when switching between User and Editor
			// document name changes could have been called by DocumentChanged
			// this should also be called if the document is saved in case the filename changes
			StringBuilder title = new StringBuilder();
			title.Append(Strings.Item("App"));
			title.Append(" (v").Append(SoftwareVersion.VersionString).Append(")");
			//if (Globals.Root.User == Users.Editor)
			//	title.Append(" - ").Append(Strings.Item("Teacher_Mode"));
			//else
			//{
			//	// in user mode append the user name if set.  If it is the default user this is omitted.  It is still distinct from teacher mode because that would include the teacher mode entry
			//	if (!string.IsNullOrEmpty(Globals.Root.Usernames[Globals.Root.UserIndex]))
			//		title.Append(" - ").Append(Globals.Root.Usernames[Globals.Root.UserIndex]);
			//}
			if (!ctrDocuments.Visible)
				// The document name is shown in the title bar, but not if we also have the tabs beneath
				title.Append(" - ").Append(m_Document.FileTitle());
			this.Text = title.ToString();
		}

		private void mnuGraphicsMode_Click(object sender, EventArgs e)
		{
			string oldToolsID = Globals.Root.CurrentConfig.PaletteSelection(new Palette.Purpose(Parameters.Tool), false);
			var oldPosition = Palette.Item(oldToolsID).Position;
			m_Document.ActivityID = Activities.IsGraphicsMode ? Activities.SAW6 : Activities.Graphics;
			Globals.OnSettingsChanged();
			// which raises an event back to do the UI update.  But the config object is rebuilt within the function, so will reflect the new activity
			Palette.UpdateCustomPalettes(Globals.Root.CurrentConfig); // otherwise Palette.Item might not return new palette - it hides ones which were not in use from list
			string newToolsID = Globals.Root.CurrentConfig.PaletteSelection(new Palette.Purpose(Parameters.Tool), false);
			var newPosition = Palette.Item(newToolsID).Position;
			if (oldPosition.Dock != newPosition.Dock)
				newPosition.CopyFrom(oldPosition);
		}


		#endregion

		#region Left panel + filling tools

		//Private Shared ReadOnly aLeftSizes() As Size = {New Size(64, 1), New Size(48, 2), New Size(32, 3), New Size(32, 4), New Size(32, 5)}
		// Width is image size; Height is number of columns
		private const int TOOLSALLOWEXTRAHEIGHT = 8; // pixels spare to allow when laying out


		private List<Shape.Shapes> FillTools()
		{
			// Returns the list of shapes which are displayed
			pnlTools.SuspendLayout();
			pnlTools.Clear(true);
			List<Shape.Shapes> list = Globals.Root.CurrentConfig.GetAllShapesInUse();
			m_FirstTool = Shape.Shapes.Null;
			{
				foreach (Shape.Shapes shape in list)
				{
					if (Globals.Root.CurrentConfig.ShapeEnabled(shape))
					{
						if (m_FirstTool == Shape.Shapes.Null)
							m_FirstTool = shape;
						RoundButton round = pnlTools.AddButton();
						round.SetTool(shape);
					}
				}
			}
			if (m_FirstTool == Shape.Shapes.Null)
				m_FirstTool = Shape.Shapes.Selector; // in case none enabled or all in folders
			if (m_eTool != m_FirstTool)
			{
				ChangeTool(m_FirstTool, true);
				Globals.OnParameterChanged(Parameters.Tool);
			}
			pnlTools.ResumeLayout();
			return list;
		}

		private void SetToolImageSizes()
		{
			int main = pnlTools.Controls.Count;
			if (main == 0 || pnlLeft.Height < 4 || this.WindowState == FormWindowState.Minimized)
				return; // startup? (Second condition mainly for minimised)
			int availableHeight = pnlLeft.Height - pnlLeft.Padding.Vertical - TOOLSALLOWEXTRAHEIGHT;
			if (availableHeight < 100)
			{
				Utilities.LogSubError("Minimal available height in tools panel: " + availableHeight);
				availableHeight = 100;
			}
			bool transformNeeded = Shape.Transformations.Any(X => Globals.Root.CurrentConfig.ShapeEnabled(X));
			// contains the amount of space to assume when checking the vertical height

			// All of these sizes are before increasing by SystemDPIRelative.  The allowed width increases as well as the button sizes, but of course the height is fixed
			int size = 64 + SharedButton.EXCESSSIZE; // Note that these now include RoundButton.EXCESSSIZE and the image is that much smaller
			int columns = 1;
			try
			{
				int folderSize = 64 + SharedButton.EXCESSSIZE;
				int folderColumns = 1;
				int permittedWidth = (48 + SharedButton.EXCESSSIZE) * 2; // 128.  This was in effect the value used in version 1
				const int minimum = 32 + SharedButton.EXCESSSIZE;
				const int step = 16;
				if (Globals.Root.CurrentConfig.ReadBoolean(Config.Smaller_Tools))
				{
					size = minimum;
					folderSize = minimum;
				}
				do
				{
					int requiredHeight = RequiredPanelHeight(size, columns, main) + RequiredPanelHeight(folderSize, folderColumns, 0);
					if (transformNeeded)
						requiredHeight += size * (columns == 1 ? 2 : 1); // There are 2 transform buttons, which are usually horizontal, but might be vertical
					if (requiredHeight * GUIUtilities.SystemDPIRelative <= availableHeight || columns >= 8)
						break; // Columns condition mainly in case the transformations and folders extras exceed the available height
					if ((columns + 1) * size <= permittedWidth || size < minimum + step)
						columns += 1;
					else
						size -= step;
				} while (true);

				pnlTools.ButtonSize = (int)(size * GUIUtilities.SystemDPIRelative);
				pnlTools.Height = (int)((RequiredPanelHeight(size, columns, main) + RequiredPanelHeight(folderSize, folderColumns, 0)) * GUIUtilities.SystemDPIRelative);
				pnlLeft.Width = (int)(Math.Max(size * columns, folderSize * folderColumns) * GUIUtilities.SystemDPIRelative); // actual button size * columns
			}
			catch (Exception ex) // getting errors in here somewhere!
			{
				Utilities.LogSubError(ex);
			}
		}

		private int RequiredPanelHeight(int buttonSize, int columns, int count)
		{
			if (count == 0)
				return 0;
			int rows = (count + columns - 1) / columns;
			return rows * buttonSize;
		}

		public void pnlLeft_SizeChanged(object sender, EventArgs e)
		{
			SetToolImageSizes();
		}

		#endregion

		#region Pages

		private int m_PageIndex = 0;
		private Page m_Page;

		public void ctrPageList_DisplayPage(int index)
		{
			DisplayPage(index);
		}

		public void DisplayPage(int index, bool documentChanged = false)
		{
			// any change of displayed page (including change of document) should be done through this
			// must process this even if the index is not changed (e.g. deleting a page, the index doesn't change but the page does)
			if (index < 0)
				return; // safety check.  This can be called with Document.IndexOf(...) and would be -1 if something has gone wrong
			if (m_Filling)
				throw new InvalidOperationException();
			m_Filling = true;
			try
			{
				if (MovingPalette != null)
					AbortPaletteMove();
				Globals.StoreEvent("DisplayPage intIndex=" + index + " bolDocumentChanged=" + documentChanged);
				m_Page = m_Document.Page(index);
				m_Page.SelectionChanged += m_Page_SelectionChanged;
				m_Page.DeselectAll();
				pnlView.DisplayPage(m_Page, m_Document);
				Globals.Root.CurrentPageIndex = index;
				ctrPageList.DisplayedIndex = index;
				StyleStateChanged();
				m_PageIndex = index;
				if (index >= m_Document.Count - 1)
				{
					// last page
					btnPageNext.Image = AM.PageNew;
					ttMain.SetToolTip(btnPageNext, Strings.Item("Menu_PageCreateNext", true));
				}
				else
				{
					btnPageNext.Image = AM.Verb_PageNext;
					ttMain.SetToolTip(btnPageNext, Strings.Item("Menu_PageNext", true));
				}
				btnPagePrevious.Enabled = index > 0;
				btnPageNext.Enabled = m_PageIndex < m_Document.Count - 1 || !m_Page.IsEmpty;
				if (!documentChanged)
					EnableGridSnap();
				// if document is changed then the document will assign the grid snapping later.  We cannot call EnableGridSnap because it might change the snapping mode
				// if it is currently grade and the document is plain paper; which will update the document (before the document has applied it is stored value)
				Globals_VerbApplicabilityChanged(); // can include page buttons

				// release any other background images to save spac
				for (int page = 0; page < m_Document.Count; page++)
				{
					if (page != index)
						m_Document.Page(page).BackgroundImage?.Release();
				}
			}
			finally
			{
				m_Filling = false;
			}
		}

		public void ctrPageList_CentreViewOn(PointF dataPos)
		{
			// Triggered when the user clicks in the page list and we centre the display where they clicked
			pnlView.CentreDisplayOn(dataPos);
		}

		public void btnPagePrevious_Click(object sender, EventArgs e)
		{
			TriggerVerb(Codes.PagePrevious, ClickPosition.Sources.Mouse);
		}

		public void btnPageNext_Click(object sender, EventArgs e)
		{
			TriggerVerb(Codes.PageNext, ClickPosition.Sources.Mouse);
		}

		public void mnuPageHeading_DropDownOpening(object sender, EventArgs e)
		{
			mnuPageMove.Enabled = m_Document.Count > 1;
			ContextMenuTools.PrepareEditMenu(mnuPageHeading.DropDownItems); // will hide some inappropriate items
																			// and adjusts the name of the next page entry.
		}

		#endregion

		#region Transactions

		internal void StoreNewTransaction(Transaction transaction, bool autoRefresh = false)
		{
			// must be called by any editing code which makes a transactional change once the transaction is complete and successful
			if (transaction == null)
				return;
			Debug.Assert(!transaction.Cancelled);
			if (transaction.Empty)
				return; // Empty checks for Cancelled
			bool shapesRemoved = transaction.CheckForDegenerateShapes();
			// returns true if it removed any shapes
			// in which case we must do an automatic refresh
			// No need to check if it has been cancelled because a cancelled election always returns Empty= true
			transaction.ChangedAtStart = m_Document.Changed;
			transaction.CurrentPage = m_Page;

			// Store in the undo buffer; and discard old buffers if there are too many
			m_Document.UndoTransactions.Add(transaction);
			var memory = (from d in m_Document.UndoTransactions select d).Sum(d => d.NominalMemory);
			var N = m_Document.UndoTransactions.Count;
			while (memory > Transaction.MAXIMUMMEMORY && N > Transaction.MINIMUMBUFFERS || N > Transaction.MAXIMUMBUFFERS)
			{
				// using too much memory, or just a silly number of buffers
				if (N > Transaction.MAXIMUMBUFFERS / 3)
				{
					// remove a few at once to make things quicker
					memory -= (from d in m_Document.UndoTransactions select d).Take(5).Sum(d => d.NominalMemory);
					m_Document.UndoTransactions.RemoveRange(0, 5);
					N -= 5;
				}
				else
				{
					memory -= m_Document.UndoTransactions[0].NominalMemory;
					m_Document.UndoTransactions.RemoveAt(0);
					N -= 1;
				}
			}
			m_Document.RedoTransactions.Clear();

			// This also now triggers various state and display changes
			m_Page.PerformLinkedChanges(transaction, this);
			if (!m_Document.Changed && !transaction.DocumentNotChanged)
				m_Document.Changed = true;
			btnPageNext.Enabled = m_PageIndex < m_Document.Count - 1 || !m_Page.IsEmpty;
			foreach (Change change in transaction)
			{
				if (!change.IsDelete && change.Current is Shape shape)
					shape.Status = Shape.StatusValues.Complete;
			}
			if (transaction.ContainsConfig)
				Globals.OnSettingsChanged();
			else if (autoRefresh || shapesRemoved)
				pnlView.InvalidateData(transaction.CalculateRefreshBounds(), StaticView.InvalidationBuffer.All);
			if (transaction.RequiresDocumentRepaint)
				pnlView.InvalidateAll();

#if DEBUG
			Debug.Assert(!m_Page.ContainsChangedShapes(), "Page still contains changed shapes after storing transaction");
			List<Shape> list = m_Page.Shapes.ToList();
			list = Shape.FlattenList(list, Shape.FlatListPurpose.DiagnosticAll);
			Dictionary<Guid, Shape> hash = new Dictionary<Guid, Shape>();
			bool duplicate = false;
			foreach (Shape shape in list)
			{
				if (!hash.ContainsKey(shape.ID))
					hash.Add(shape.ID, shape);
				else
				{
					duplicate = true;
					Debug.WriteLine("Shape: " + shape.ShapeCode + "/" + shape.ID + " is a duplicate");
				}
			}
			if (duplicate)
				Debug.Fail("Duplicate shapes after storing transaction");
			if (m_Page.Any())
				m_Page.CheckZ("Z index of last shape on page wrong after storing transaction");
			if (m_Page.SelectedCount == 1)
				pnlView_ChangeDiagnostic(m_Page.SelectedShapes.First());
			if (m_Document.UndoTransactions.Count == 1)
				Globals.NotifyVerbApplicabilityChanged(); // Because "undo" becomes available when first transaction is stored
#endif
			transaction.Stored = true;
			Globals.OnTransactionStored(transaction);
		}

		internal void IndirectEffectsUndoRedo(Transaction transaction, bool isUndo)
		{
			if (transaction.Contains(m_Document))
			{
				// may have added or removed pages, so refresh page selection
				if (m_PageIndex >= m_Document.Count)
					m_PageIndex = m_Document.Count - 1;
				DisplayPage(m_PageIndex);
			}
			else
			{
				if (transaction.Contains(m_Page.Paper))
					EnableGridSnap();
				Debug.Assert(transaction.CurrentPage != null);
				btnPageNext.Enabled = m_PageIndex < m_Document.Count - 1 || !m_Page.IsEmpty;
			}
			if (transaction.ContainsConfig)
				Globals.OnSettingsChanged();
			else
				Globals.NotifyVerbApplicabilityChanged();
			Globals.OnTransactionStored(transaction, isUndo);
			if (transaction.IsPageSizeChange)
			{
				m_Page.NotifySettingsChanged(Shape.EnvironmentChanges.Paper);
				pnlView.InvalidateAll();
				Globals.OnCurrentPageSizeChanged();
				MatchWindowToSet();
			}
		}

		#endregion

		#region IParameterGUI

		public int ParameterValue(Parameters parameter)
		{
			switch (parameter)
			{
				case Parameters.Tool:
					return (int)CurrentTool;
				// with filling there is a special case where empty pattern and empty colour interact (if either is empty, the other is displayed as empty)
				case Parameters.FillColour:
					if (m_aDisplayedStyle[(int)Parameters.FillPattern] == (int)Shape.FillStyleC.Patterns.Empty)
						return Color.Empty.ToArgb();
					return m_aDisplayedStyle[(int)parameter];
				case Parameters.FillPattern:
					if (m_aDisplayedStyle[(int)Parameters.FillColour] == Color.Empty.ToArgb())
						return (int)Shape.FillStyleC.Patterns.Empty;
					return m_aDisplayedStyle[(int)parameter];
				case Parameters.Action_ShowGrid:
					return (pnlView.CurrentPage?.Paper?.GridVisible ?? false) ? 1 : 0; // 1 for visible, 0 for hidden
				case Parameters.Action_Snap:
					return (int)pnlView.SnapMode;
				default:
					if (parameter >= Parameters.FirstStyle && parameter <= Parameters.LastStyle)
						return m_aDisplayedStyle[(int)parameter];
					else
					{
						Debug.Fail("Unexpected parameter: " + parameter);
						return 0;
					}
			}
		}

		public void SetParameterValue(int value, Parameters parameter)
		{
			// this public Set is only called when the user makes a change.  Changes to the display happen internally not via this accessor
			switch (parameter)
			{
				case Parameters.Tool:
					if (value != (int)Shape.Shapes.SelectorOrNull && !Globals.Root.CurrentConfig.ShapeEnabled((Shape.Shapes)value))
						return; // SelectorOrNull is always treated as available
					ChangeTool((Shape.Shapes)value); // will trigger the event
					break;
				default:
					if (parameter >= Parameters.FirstStyle && parameter <= Parameters.LastStyle)
					{
						int old = m_aDisplayedStyle[(int)parameter];
						m_aDisplayedStyle[(int)parameter] = value;
						StyleParameterDefaultObject(parameter).SetParameterValue(value, parameter);
						// the FillPattern and FillColour values can affect how the other one is reported
						switch (parameter)
						{
							case Parameters.FillColour:
								if (value != 0 && m_aDisplayedStyle[(int)Parameters.FillPattern] == (int)Shape.FillStyleC.Patterns.Empty)
									// if data contains Empty pattern, reset it to Solid
									SetParameterValue((int)Shape.FillStyleC.Patterns.Solid, Parameters.FillPattern);
								Globals.OnParameterChanged(Parameters.FillPattern);
								break;
							case Parameters.FillPattern:
								if (value != (int)Shape.FillStyleC.Patterns.Empty && m_aDisplayedStyle[(int)Parameters.FillColour] == 0)
									// if data contains Empty pattern, reset it to Solid
									SetParameterValue(Shape.FillStyleC.DEFAULTCOLOUR.ToArgb(), Parameters.FillColour);
								Globals.OnParameterChanged(Parameters.FillColour);
								break;
							case Parameters.ArrowheadStartType:
								if (old == (int)Lined.ArrowheadC.Styles.None || value == (int)Lined.ArrowheadC.Styles.None)
								{
									// the size buttons will need to update themselves as well, because previously none was selected
									// unfortunately we need to notify them that the type has changed first, otherwise they will ignore the size change
									// which does mean that this next line is a duplicate of the one at the end of the function
									Globals.OnParameterChanged(parameter);
									Globals.OnParameterChanged(Parameters.ArrowheadStartSize);
								}
								break;
							case Parameters.ArrowheadEndType:
								if (old == (int)Lined.ArrowheadC.Styles.None || value == (int)Lined.ArrowheadC.Styles.None)
								{
									Globals.OnParameterChanged(parameter);
									Globals.OnParameterChanged(Parameters.ArrowheadEndSize);
								}
								break;
							case Parameters.ArrowheadStartSize:
								// if the size is changed, when the type is None, reset the type to something so that the size functions
								if (m_aDisplayedStyle[(int)Parameters.ArrowheadStartType] == (int)Lined.ArrowheadC.Styles.None)
									SetParameterValue((int)Lined.ArrowheadC.Styles.SimpleSolid, Parameters.ArrowheadStartType);
								break;
							case Parameters.ArrowheadEndSize:
								// if the size is changed, when the type is None, reset the type to something so that the size functions
								if (m_aDisplayedStyle[(int)Parameters.ArrowheadEndType] == (int)Lined.ArrowheadC.Styles.None)
									SetParameterValue((int)Lined.ArrowheadC.Styles.SimpleSolid, Parameters.ArrowheadEndType);
								break;
						}
					}
					else
					{
						Debug.Fail("Unexpected parameter: " + parameter);
						return;
					}
					ApplyUserStyleChangesToSelection(parameter, value);
					Globals.OnParameterChanged(parameter);
					break;
			}
		}

		public List<Shape> SelectedOrCurrentShapes
		{
			get
			{
				if (pnlView.OngoingShape != null)
					return new List<Shape> { pnlView.OngoingShape };
				return m_Page.SelectedShapes;
			}
		}

		#endregion

		#region Verbs and actions

		private void TriggerVerb(Codes code, ClickPosition.Sources source)
		{
			Globals.StoreEvent("Trigger: " + code);
			Verb implementation = Verb.Find(code);
			if (!VerbApplicable(code))
			{
				Debug.WriteLine("Ignored not applicable verb: " + code);
				return; // means that we don't need to make so many protection checks below
			}
			if (implementation == null)
			{
				Debug.Fail("Unknown verb: " + code);
				return;
			}
			if (implementation.AbandonsCurrent)
				pnlView.ConcludeOngoing();
			Transaction transaction = new Transaction(); // doesn't matter if this is not needed
			implementation.Trigger(source, pnlView, transaction);
			if (!transaction.Cancelled && !transaction.Stored)
				StoreNewTransaction(transaction, implementation.AutoRefreshAfterTrigger);
			if (implementation.ImmediateRefresh)
				ctrPageList.DoPendingRefresh();
		}

		internal bool VerbApplicable(Codes code)
		{
			// if an item is not listed below it is assumed to be applicable
			Verb implementation = Verb.Find(code);
			if (implementation == null)
			{
				Utilities.LogSubError("Unknwon verb: " + code);
				return false;
			}
			return implementation.IsApplicable(pnlView);
		}

		public void PerformAction(Action action, ClickPosition.Sources source) //, Optional ByVal bolQueueIfDialog As Boolean = False)
		{
			// if from keyboard this must be delayed if it could open a dialog - otherwise the KeyPress event might fire (and do something) although this KeyDown
			// will be marked handled - but it all ends up out of sequence if the dialog runs an event loop
			if (source == ClickPosition.Sources.Keyboard && action.MightOpenModalDialog)
			{
				m_ActionQueue.Enqueue(action);
				Globals.Root.RequestDelayedCall(DoQueuedActions);
				return;
			}
			if (action.Change == Parameters.Action_Verb)
				TriggerVerb((action as Verb).Code, source);
			else
				action.Trigger(source, pnlView, null);
		}


		private readonly Queue<Action> m_ActionQueue = new Queue<Action>();

		// actions triggered by keys are Qed - because if the action opens a modal dialog the key event doesn't return immediately
		// and the system will try to handle it (e.Handled not taken effect as it hasn't returned)
		private void DoQueuedActions()
		{
			while (m_ActionQueue.Count > 0)
			{
				PerformAction(m_ActionQueue.Dequeue(), ClickPosition.Sources.Deferred); // only queued if they came from the keyboard
			}
		}

		private void Verb_Button_Click(object sender, EventArgs e)
		{
			// any button where the verb is in the tag "Verb/Something"
			// the event must be wired up manually in the constructor (the form is not searched for these)
			if (Globals.CheckDiscardClick((Control)sender))
				return;
			Codes code = ParseVerbButton((Control)sender);
			if (code == Codes.None)
				return;
			if (!VerbApplicable(code))
				Utilities.LogSubError("Verb_Button_Click: verb is not applicable: " + code);
			else
				TriggerVerb(code, ClickPosition.Sources.VerbButton);
			Globals.RestoreFocus();
		}

		private void Verb_Button_Enter(object sender, EventArgs e)
		{
			Codes code = ParseVerbButton((Control)sender);
			if (code != Codes.None)
				Globals.SetHoverPrompt("Verb_" + code, "Verb_64_" + code); // image usually not defined
			else
				Globals.ClearHover();
		}

		private void Verb_Button_Leave(object sender, EventArgs e)
		{
			Globals.ClearHover();
		}

		private static Codes ParseVerbButton(Control ctrSender)
		{
			// returns the verb for one of the buttons marked as a verb button (verb is in the tag)
			if (!(ctrSender.Tag is string) || !ctrSender.Tag.ToString().StartsWith("Verb/"))
			{
				Utilities.LogSubError("Verb_Button_Click: tag does not start \'Verb/\'");
				return Codes.None;
			}
			string verbName = ctrSender.Tag.ToString().Substring(5);
			return (Codes)Enum.Parse(typeof(Codes), verbName);
			// note version of this in PalettePanel.SetToolTips - change if format changes
		}

		private void Globals_VerbApplicabilityChanged() // VerbButtonsUpdateEnabled
		{
			// At the moment this is only called when the selection changes; because the buttons are only dependent upon the selection
			// Can also be triggered by shapes (e.g. NumberLine changing direction)
			foreach (Control control in m_VerbButtons)
			{
				string tag = (string)control.Tag;
				Debug.Assert(tag.StartsWith("Verb/"));
				Codes code = (Codes)Enum.Parse(typeof(Codes), tag.Substring(5));
				control.Enabled = VerbApplicable(code);
			}
		}

		/// <summary>Parts of PerformAction specific to one application.  Returns true if handled in here</summary>
		private void mnuSystemConfig_Click(object sender, EventArgs e)
		{
			// only visible in debug
			frmEditConfig.EditConfig(Config.Levels.System, m_Document, Config.SystemConfig); // it is saved automatically
		}

		private void mnuActivityConfig_Click(object sender, EventArgs e)
		{
			// only visible in debug
			frmEditConfig.EditConfig(Config.Levels.ActivityBoth, m_Document);
		}
		private void mnuActivityConfigUser_Click(object sender, EventArgs e)
		{
			// only visible in debug
			frmEditConfig.EditConfig(Config.Levels.ActivityUser, m_Document);
		}

		internal void DoStartVerb()
		{
			if (CheckDiscardCurrent(true))
			{
				m_Document = null;
				// to avoid triggering another save question if the user didn't save here, and then closes the menu page
				// LeavingScreen will save palette positions
				if (m_Page != null)
					m_Page.SelectionChanged -= this.m_Page_SelectionChanged;
				m_Page = null;
				Globals.Root.ShowMenu();
			}

		}

		/// <summary>Returns true if it is OK to close the document</summary>
		internal bool CheckDiscard(Document document)
		{
			if (document.Changed == false || document.IsPaletteWithin)
				return true;
			DialogResult result = DialogResult.None;
			if (result == DialogResult.None)
			{
				if (string.IsNullOrEmpty(document.Filename))
					// Document has not previously been saved
					result = GUIUtilities.QuestionBox(Strings.Item("Confirm_DiscardNew"), MessageBoxButtons.YesNoCancel);
				else
					result = GUIUtilities.QuestionBox(Strings.Item("Confirm_DiscardExisting").Replace("%0", Path.GetFileNameWithoutExtension(document.Filename)), MessageBoxButtons.YesNoCancel);
			}
			switch (result)
			{
				case DialogResult.Yes:
					TriggerVerb(Codes.Save, ClickPosition.Sources.Irrelevant); // but we need to detect if the user cancels the save box, if this was a new document
					if (document.Changed)
						return false; // if the document was saved it would be marked as not changed
					return true; // continue now that we have saved
				case DialogResult.No:
					return true; // continue without saving
				default:
					return false;
			}
		}

		#endregion

		#region Verbs - Support for Implementation

		#region Document and file menu and some external calls relating to this

		private void Engine_RequestClose(CancelEventArgs e)
		{
			if (!CheckDiscardCurrent(true))
				e.Cancel = true;
		}

		public bool CheckDiscardCurrent(bool all)
		{
			// prompt the user to save the current document, returns false to cancel
			// if bolAll is true, it does so for every unsaved document in the list
			if (m_Document == null)
				return true;
			pnlView.ConcludeOngoing();
			//If Not Licence.CurrentApplication.IsFull Then Return True ' because they can't save anyway
			if (all && Globals.Root.DocumentsCount > 1)
			{
				for (int index = 0; index <= Globals.Root.DocumentsCount - 1; index++)
				{
					if (!CheckDiscard(Globals.Root.Documents(index)))
						return false;
				}
				return true;
			}
			else
				return CheckDiscard(m_Document);
		}

		public void frmMain_FormClosing(object sender, FormClosingEventArgs e)
		{
#if !DEBUG || true // not done in debug mode, because this is just annoying when writing the software
			if (!CheckDiscardCurrent(true))
				e.Cancel = true;
#endif
		}

		public void frmMain_FormClosed(object sender, FormClosedEventArgs e)
		{
			Globals.Root.CloseApplication();
		}


		public void RequestLoadDocument(string file)
		{
			// Equivalent to the LoadVerb, but the file is already known.  File cannot be an error report
			try
			{
				pnlView.ConcludeOngoing();
				Globals.Root.OpenFile(file);
			}
			catch (DataReader.FileTypeException)
			{
				MessageBox.Show(Strings.Item("File_Wrong_Not_Document"));
				// other exceptions mostly handled by caller
			}
		}

		#endregion

		internal void StoreStyleDefaults(bool documentDefault, Transaction transaction)
		{
			Document document;
			if (documentDefault)
			{
				document = m_Document;
				MessageBox.Show(Strings.Item("Default_Styles_Stored"));
			}
			else // Otherwise this is the user default
			{
				document = Config.UserUser.Document;
				if (Globals.Root.User == Users.Editor)
					MessageBox.Show(Strings.Item("Default_Styles_StoredUserNotTeacher").Replace("%0", Globals.Root.CurrentUserDisplayname));
				else
					MessageBox.Show(Strings.Item("Default_Styles_StoredUser"));
			}
			transaction.Edit(document);
			document.InitialLineStyle = new Shape.LineStyleC();
			document.InitialLineStyle.CopyFrom(m_LineStyle);
			document.InitialFillStyle = new Shape.FillStyleC();
			document.InitialFillStyle.CopyFrom(m_FillStyle);
			document.InitialTextStyle = new Shape.TextStyleC();
			document.InitialTextStyle.CopyFrom(m_TextStyle);
		}

		#endregion

		#region Left panel and filling tools
		public void pnlTools_Paint(object sender, PaintEventArgs e)
		{
		}

		public void pnlTools_Click(object sender, EventArgs e)
		{
		}

		#endregion

		#region Keys, Pads etc

		public void CombinedKeyDown(CombinedKeyEvent e)
		{
			// process action key
			// This is called when a key has not been needed for typing into any focal control or shape.  Usually called by the function above
			// but will also be called by the view if it is given the key because we are typing, but the shape doesn't actually consume the key
			//Globals.StoreEvent("CombinedKeyDown " + e.KeyCode);
			{
				Functions.Action objAction = Globals.Root.CurrentConfig.KeyAction(e.KeyData);
				//Debug.WriteLine(ParameterSupport.KeyDescription(e.KeyData) + " = " + objAction.ToString)
				if (!objAction.IsEmpty)
				{
					PerformAction(objAction, ClickPosition.Sources.Keyboard);
					e.Handled = true;
					return;
				}
			}

			// key down
			if (e.KeyCode == Keys.ShiftKey)
			{
				if (m_eTool != Shape.Shapes.Selector && pnlView.ShiftCanSelect && pnlView.Focused)
				{
					Shape.Shapes ePrevious = m_eTool; // cannot assign m_eToolBeforeShift directly because ChangeTool will clear it
					ChangeTool(Shape.Shapes.Selector, true);
					m_ToolBeforeShift = ePrevious;
				}
			}
		}

		// I have completely replaced the standard key event logic.  There are a couple of problems:
		// we need the form to receive the keys, but KeyPreview means it receives first, and it should be last if they haven't been handled by anything else
		// also there is the perennial problem of the distinction between KeyDown and KeyPress.  All the configurable stuff responds to KeyDown
		// but should only trigger if nothing used the key for typing (which requires KeyPress - which happens second in .net)
		// AltGr, see: http://en.wikipedia.org/wiki/AltGr_key#Swedish_keymap

		internal IPaletteContainer FocalPaletteContainer()
		{
			Control current = GUIUtilities.GetFocusControl();
			Debug.WriteLine("Focus is: " + current.GetType().Name);
			while (current != null)
			{
				if (current is IPaletteContainer)
					return (IPaletteContainer)current;
				current = current.Parent;
			}
			return null;
		}

		public void CombinedKeyUp(CombinedKeyEvent e)
		{
			Globals.StoreEvent("CombinedKeyUp " + e.KeyCode);
			if (e.KeyCode == Keys.ShiftKey)
			{
				if (m_ToolBeforeShift != Shape.Shapes.Null)
				{
					ChangeTool(m_ToolBeforeShift, true);
					m_ToolBeforeShift = Shape.Shapes.Null;
				}
			}
		}

		public void frmMain_GotFocus(object sender, EventArgs e)
		{
			GUIUtilities.CurrentFocus = null;
		}

		public void frmMain_LostFocus(object sender, EventArgs e)
		{
			if (m_ToolBeforeShift != Shape.Shapes.Null)
			{
				ChangeTool(m_ToolBeforeShift);
				m_ToolBeforeShift = Shape.Shapes.Null;
			}
			GUIUtilities.CurrentFocus = this;
		}

		internal void SimulateKey(Keys key)
		{
			Globals.StoreEvent("SimulateKey eHey=" + key);
			CombinedKeyEvent e = new CombinedKeyEvent(key) { Character = key.ToCharacter(), Simulated = true };
			SendCombinedKeyEvent(e, true);
			e.Handled = false;
			SendCombinedKeyEvent(e, false);

		}

		public void SimulateKey(char ch)
		{
			// generates a (simulated) keypress for the given character.  Must be a typeable character not, e.g., cursor key
			Globals.StoreEvent("SimulateKey ch=" + ch);
			Keys key = Keys.A;
			CombinedKeyEvent e = new CombinedKeyEvent(key);
			e.Character = ch;
			e.Simulated = true;
			SendCombinedKeyEvent(e, true);
			e.Handled = false;
			SendCombinedKeyEvent(e, false);
		}

		#endregion

		#region Menus

		// the menus generated in the form designer mostly have the functionality specified in the tag.  This is text in the form designer
		// which can be either <parameter_name>/<parameter_value> for something which changes the value of a parameter or "verb"/<verb_name>
		// to trigger an action.  During the form load this code iterate through all the menu is replacing the text tags With Functions.Actions
		// if the menu is for a verb the tag can be omitted if the text is [Verb_<verbname>]

		public void mnuDoubleClick_Click(object sender, EventArgs e)
		{
			// Triggers the double-click activity on the currently selected object
			//	TriggerVerb(Verbs.DoubleClick, ClickPosition.Sources.Mouse)
		}

		public void mnuRecent_DropDownOpening(object sender, EventArgs e)
		{
			mnuRecent.DropDownItems.Clear();
			List<string> list = Config.UserUser.RecentFiles;
			for (int index = list.Count - 1; index >= 0; index--)
			{
				ToolStripItem mnu = mnuRecent.DropDownItems.Add(Path.GetFileName(list[index]));
				mnu.Click += mnuRecent_Click;
			}
		}

		private void mnuRecent_Click(object sender, EventArgs e)
		{
			// Handler for a click on one of the subitems
			int index = mnuRecent.DropDownItems.IndexOf((ToolStripItem)sender); // Config.User(Users.User).RecentFiles.IndexOf(sender)
			if (index < 0)
			{
				Utilities.LogSubError("mnuRecent_Click: menu item not found in recent menu");
				return;
			}
			index = Config.UserUser.RecentFiles.Count - 1 - index; // displayed list is reversed!  intIndex now index in stored list
			string file = Config.UserUser.RecentFiles[index];
			try
			{
				Globals.Root.OpenFile(file, false);
			}
			catch (FileNotFoundException)
			{
				MessageBox.Show(Strings.Item("Recent_Not_Found").Replace("%0", file));
			}
			catch (Exception ex)
			{
				MessageBox.Show(Strings.Item("Recent_Failed").Replace("%0", ex.Message));
			}
		}

		public void mnuEdit_DropDownOpening(object sender, EventArgs e)
		{
			// need to update the entry which does the same as double-clicking with the selector
			// This now hides various items when they are not applicable, and the same code is applied to the page menu
			// Note this does not recurse
			ContextMenuTools.PrepareEditMenu(mnuEdit.DropDownItems);
			// above will disable these items when not applicable, but better to hide entirely in non-graphics mode
			bool advanced = Globals.Root.CurrentConfig.ReadBoolean(Config.Advanced_Graphics);
			mnuVerbActive.Visible = mnuVerbInactive.Visible = mnuDividerMakeActive.Visible = advanced;
			mnuMakeMask.Visible = mnuRemoveMask.Visible = advanced;
		}

		private void UpdateMenuKeys()
		{
			// will fail if used (e.g. through ApplyConfiguration) before Load event has fired, because menus not initialised
			foreach (ToolStripMenuItem menuItem in mnuTop.Items)
			{
				ContextMenuTools.UpdateMenuKeys(menuItem);
			}
		}


		#region Options, snap mode
		public void mnuOptions_DropDownOpening(object sender, EventArgs e)
		{
			mnuResizeDoc.Checked = Globals.Root.CurrentConfig.ReadBoolean(Config.Resize_Document_ToWindow, true);
			mnuUserUser.Checked = Globals.Root.User == Users.User;
			mnuSnapGrid.Checked = pnlView.SnapMode == Shape.SnapModes.Grid;
			mnuSnapShape.Checked = pnlView.SnapMode == Shape.SnapModes.Shape;
			mnuSnapOff.Checked = pnlView.SnapMode == Shape.SnapModes.Off;
			mnuSnapAngle.Checked = pnlView.SnapMode == Shape.SnapModes.Angle;
			mnuDisplayDiagnostic.Checked = pnlConstruction.Visible;
			mnuZoomPage.Checked = pnlView.SpecialZoom == StaticView.SpecialZooms.FitPage;
			mnuZoomWidth.Checked = pnlView.SpecialZoom == StaticView.SpecialZooms.FitWidth;
		}

		private void mnuResizeDoc_Click(object sender, EventArgs e)
		{
			Transaction transaction = new Transaction();
			transaction.Edit(Config.UserEditor);
			Config.UserEditor.Write(Config.Resize_Document_ToWindow, !Globals.Root.CurrentConfig.ReadBoolean(Config.Resize_Document_ToWindow, true));
			Globals.Root.StoreNewTransaction(transaction);
			Globals.OnSettingsChanged();
			if (Globals.Root.CurrentConfig.ReadBoolean(Config.Resize_Document_ToWindow, true))
				frmMain_Resize(this, EventArgs.Empty);
		}

		public void mnuSnapOff_Click(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Off);
		}

		public void mnuSnapShape_Click(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Shape);
		}

		public void mnuSnapAngle_Click(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Angle);
		}

		public void mnuSnapGrid_Click(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Grid);
		}

		internal void UserChangeSnapMode(Shape.SnapModes newMode)
		{
			// the difference between this and Actual... is that if the user reselect the same snapping mode it switches it off
			if (newMode == pnlView.SnapMode)
				newMode = Shape.SnapModes.Off;
			ActualChangeSnapMode(newMode);
		}

		private void ActualChangeSnapMode(Shape.SnapModes newMode)
		{
			pnlView.SnapMode = newMode;
			if (m_Document != null)
				m_Document.SnapMode = newMode;
			switch (newMode)
			{
				case Shape.SnapModes.Off:
					rdoSnapAngle.Checked = false;
					rdoSnapGrid.Checked = false;
					rdoSnapShape.Checked = false;
					break;
				case Shape.SnapModes.Grid:
					rdoSnapGrid.Checked = true;
					break;
				case Shape.SnapModes.Shape:
					rdoSnapShape.Checked = true;
					break;
				case Shape.SnapModes.Angle:
					rdoSnapAngle.Checked = true;
					break;
				default:
					Debug.Fail("Unexpected SnapMode in ChangedSnapMode");
					break;
			}
			// We don't actually put this in a transaction, it will probably just confuse people if undo reverts this
		}

		/// <summary>Called when the ShowGrid parameter is set;  actually just toggles it if user initiated, ignoring the value</summary>
		internal void ChangeGridVisible(bool value, bool userInitiated)
		{
			if (userInitiated)
				value = !m_Page.Paper.GridVisible;
			m_Page.Paper.GridVisible = value;
			Globals.OnParameterChanged(Parameters.Action_ShowGrid);
			pnlView.InvalidateAll();
		}

		#endregion

		#region Context menu
		private ContextMenuStrip m_mnuContext; // Created as a (mostly) copy of the Edit menu
		private ContextMenuStrip m_mnuPageContext;

		private void CreateContextMenus() // called by constructor
		{
			m_mnuContext = new ContextMenuStrip();
			ContextMenuTools.DuplicateMenu(mnuEdit.DropDownItems, m_mnuContext.Items);
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_AddVertex]" });
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_RemoveVertex]" });
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_CornerVertex]" });
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_SmoothVertex]" });
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_ConvertToLine]" });
			m_mnuContext.Items.Add(new ToolStripMenuItem { Text = "[Verb_ConvertToBezier]" });
			ContextMenuTools.InitialiseMenu(m_mnuContext); // has already been done, but existing items will be ignored (as tag changed)

			m_mnuPageContext = new ContextMenuStrip();
			ContextMenuTools.DuplicateMenu(mnuPageHeading.DropDownItems, m_mnuPageContext.Items);
		}

		public void ctrPageList_DisplayContextMenu(Point pt)
		{
			ContextMenuTools.PrepareEditMenu(m_mnuPageContext.Items);
			ContextMenuTools.PrepareContextMenu(m_mnuPageContext);
			m_mnuPageContext.Show(ctrPageList, pt);
		}

		private void pnlView_DisplayContextMenu(Point pt)
		{
			// The view will have tried to select any shape under the click.  If nothing, we display a different menu
			if (m_Page.SelectedCount == 0)
			{
				ContextMenuTools.PrepareContextMenu(ctxBackground);
				ctxBackground.Show(pnlView, pt);
			}
			else
			{
				ContextMenuTools.PrepareEditMenu(m_mnuContext.Items);
				ContextMenuTools.PrepareContextMenu(m_mnuContext);
				m_mnuContext.Show(pnlView, pt);
			}
		}

		#endregion

		public void mnuFile_DropDownOpening(object sender, EventArgs e)
		{
			mnuRecent.Enabled = Config.UserUser.RecentFiles.Count > 0;
			mnuExportPage.Visible = Globals.Root.User == Users.Editor;
		}

		private void mnuSAWSet_DropDownOpening(object sender, EventArgs e)
		{
			ContextMenuTools.PrepareEditMenu(mnuSAWSet.DropDownItems);
		}

		#endregion

		#region Editing, changing current tool
		// these mostly mirror things in pnlView at the moment
		private Shape.Shapes m_eTool;
		private Shape.Shapes m_ToolBeforeShift = Shape.Shapes.Null; // which was selected before control was pressed.  Null if control not believed pressed
		private Shape.Shapes CurrentTool
		{ get { return m_eTool; } }

		/// <summary>Changes the current tool</summary>
		/// <param name="newTool"></param>
		/// <param name="dontDeselect">If true then this is an auto selectio and not the user clicking on the tool (eg auto select of default, or select F9 while shift held)</param>
		internal void ChangeTool(Shape.Shapes newTool, bool dontDeselect = false)
		{
			//Debug.WriteLine(eNew.ToString)
			// It is just maybe possible that m_Page is not defined (?- error on 17th June).  If the document is changed this is called before DisplayPage
			if (newTool == Shape.Shapes.SelectorOrNull)
				newTool = Globals.Root.CurrentConfig.ShapeEnabled(Shape.Shapes.Selector) ? Shape.Shapes.Selector : Shape.Shapes.Null;
			if (MovingPalette != null)
				AbortPaletteMove();
			if (newTool != Shape.Shapes.Selector && newTool != Shape.Shapes.Null && !Globals.Root.CurrentConfig.ShapeEnabled(newTool))
				return; // mainly to block key equivalents
			m_eTool = newTool;
			m_ToolBeforeShift = Shape.Shapes.Null;
			pnlView.NotifyCurrentToolChanged(newTool, dontDeselect);
			if (m_Page == null || m_Page.SelectedCount == 0)
			{
				// make sure that the default values are displayed
				DisplayDefaultValues();
			}

			StyleStateChanged(); // in order to update applicability
			if (!dontDeselect)
				Globals.OnParameterChanged(Parameters.Tool);
		}

		#endregion

		#region Styling
		// these are the values displayed.  They are not necessarily the default values applied to a new object, since the currently displayed values
		// update to reflect every object selected.  The default only changes as the user selects an option.
		private readonly int[] m_aDisplayedStyle = new int[(int)Parameters.LastStyle + 1];

		// the default settings used for new objects:
		private readonly Shape.LineStyleC m_LineStyle = new Shape.LineStyleC();
		private readonly Shape.TextStyleC m_TextStyle = new Shape.TextStyleC();
		private readonly Shape.TextStyleC m_TextStyleFreeAlignment = new Shape.TextStyleC(); // only the Alignment is used, and it is only used with FreeText
		private readonly Shape.FillStyleC m_FillStyle = new Shape.FillStyleC(); // will be a reference to one of the two above
		private readonly Lined.ArrowheadC m_StartArrowhead = new Lined.ArrowheadC(false);
		private readonly Lined.ArrowheadC m_EndArrowhead = new Lined.ArrowheadC(true);

		// Versions which keep the default values (set in constructor)
		private readonly Shape.LineStyleC m_LineStyleDefault = new Shape.LineStyleC();
		private readonly Shape.TextStyleC m_TextStyleDefault = new Shape.TextStyleC();
		private readonly Shape.FillStyleC m_FillStyleDefault = new Shape.FillStyleC(); // will be a reference to one of the two above

		private void SetDefaultStyles(bool startup)
		{
			// fills in the default/current style objects.  Used when the form is opened, and possibly as we change document
			// if bolStartup then changed events raised whether they are changed or not, and all of them are set to applicable
			m_LineStyle.SetDefaults();
			m_FillStyle.SetDefaults();
			m_TextStyle.SetDefaults();
			m_EndArrowhead.SetDefaults();
			m_StartArrowhead.SetDefaults();
			if (!startup)
			{
				// Document default takes priority if it is defined
				foreach (var document in new[] { Config.UserUser.Document, Activities.GetActivitySettings(), m_Document })
				{
					if (document?.InitialLineStyle != null) // They must either all be nothing or all defined.  This also checks if document is nothing
					{
						CopyStyleWhereNonDefault(m_LineStyle, document.InitialLineStyle, m_LineStyleDefault);
						CopyStyleWhereNonDefault(m_FillStyle, document.InitialFillStyle, m_FillStyleDefault);
						CopyStyleWhereNonDefault(m_TextStyle, document.InitialTextStyle, m_TextStyleDefault);
					}
				}
			}

			// now set these as the currently displayed values as well...
			for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
			{
				if (parameter == (Parameters)9 || parameter == (Parameters)10)
					continue;
				if (startup || m_aDisplayedStyle[(int)parameter] != StyleParameterDefaultObject(parameter).ParameterValue(parameter))
				{
					m_aDisplayedStyle[(int)parameter] = StyleParameterDefaultObject(parameter).ParameterValue(parameter);
					if (startup)
						Globals.SetApplicable(true, parameter);
					Globals.OnParameterChanged(parameter);
				}
			}
		}

		private void CopyStyleWhereNonDefault(Shape.StyleBase target, Shape.StyleBase source, Shape.StyleBase defaultStyle)
		{
			// From version 2.06 the logic has changed such that only non-default values are applied at each level.  Previously once a configuration was found containing
			// Default styles it was used and no further configurations were used.  But this meant that the activity (some of which now have defaults) blocked any user settings
			foreach (var parameter in target.ApplicableParameters())
			{
				var value = source.ParameterValue(parameter);
				var defaultValue = defaultStyle.ParameterValue(parameter);
				if (value != defaultValue)
					target.SetParameterValue(value, parameter);
			}
		}

		private void ApplyUserStyleChangesToSelection(Parameters parameter, int value)
		{
			// the caller should already have updated the default objects above - there is no easy way for this function to know which of the default object is affected
			// (selection between the style objects for shapes is included within shape itself)
			// this updates the shape currently being drawn and/or the currently selected shapes
			// first get the editing form to update the floating object...
			pnlView.ApplyUserStyleChangesToOngoingShape(parameter, value); // does its own invalidation where necessary
			if (m_Page.SelectedCount > 0)
			{
				Transaction transaction = new Transaction();
				// the ongoing shape (if any, above) can ignore this, because it is not yet part of the data
				// this must update the base graphics buffer because the shapes are drawn both in the base and as the transparent highlight
				var invalid = RectangleF.Empty;
				// Shape.FlattenList ensures that the list contains all subjects within groups
				List<Shape> list = Shape.FlattenList(m_Page.SelectedShapes, Shape.FlatListPurpose.Style);
				foreach (Shape shape in list)
				{
					Shape.StyleBase style = shape.StyleObjectForParameter(parameter);
					if (style != null)
					{
						// this shape can be changed
						int oldValue = style.ParameterValue(parameter);
						transaction.Edit(shape);
						Geometry.Extend(ref invalid, shape.RefreshBounds());
						style.SetParameterValue(value, parameter);
						shape.NotifyStyleChanged(parameter, oldValue, value);
						Geometry.Extend(ref invalid, shape.RefreshBounds()); // because the refresh bounds might change as the styling changes (e.g. if bounding line width changes)
					}
				}
				DisplayShapeStyles(list); // in case shapes didn't actually accept the changes
				if (!invalid.IsEmpty)
					pnlView.InvalidateData(invalid, StaticView.InvalidationBuffer.Base | StaticView.InvalidationBuffer.Selection);
				if (!transaction.Empty)
					StoreNewTransaction(transaction);
				// rectangle might be empty if no shapes were actually affected (i.e. if none of the selected shapes actually use this parameter)
			}
		}

		public void ApplyDefaultStyles(Shape shape)
		{
			// applies any of the default styles which the shape supports
			// The actual parameters chosen here arbitrary.  However it is important that all of the shapes support this parameter for the given object
			// e.g. tally supports line width, but not line pattern
			ApplyDefaultStyles(shape, Parameters.LineWidth, m_LineStyle);
			ApplyDefaultStyles(shape, Parameters.FillColour, m_FillStyle);
			ApplyDefaultStyles(shape, Parameters.TextColour, m_TextStyle); // FontSize
			ApplyDefaultStyles(shape, Parameters.ArrowheadEndSize, m_EndArrowhead);
			ApplyDefaultStyles(shape, Parameters.ArrowheadStartSize, m_StartArrowhead);
			if (shape.ShapeCode == Shape.Shapes.FreeText && shape.StyleObjectForParameter(Parameters.TextAlignment) != null)
				shape.StyleObjectForParameter(Parameters.TextAlignment).SetParameterValue((int)m_TextStyleFreeAlignment.Alignment, Parameters.TextAlignment);
		}

		private void ApplyDefaultStyles(Shape shape, Parameters parameter, Shape.StyleBase defaultStyle)
		{
			Shape.StyleBase style = shape.StyleObjectForParameter(parameter, true);
			if (style != null)
			{
				// Note that this asks the style object from the shape which parameters are applicable.  It doesn't necessarily match the default style object
				// (e.g. clock, tally use slightly odd lists)
				foreach (var applicable in style.ApplicableParameters())
				{
					style.SetParameterValue(defaultStyle.ParameterValue(applicable), applicable);
				}
			}
		}

		internal Shape.StyleBase StyleParameterDefaultObject(Parameters parameter)
		{
			// See Globals
			switch (parameter)
			{
				case Parameters.FillColour:
				case Parameters.FillPattern:
					return m_FillStyle;
				case Parameters.LineColour:
				case Parameters.LinePattern:
				case Parameters.LineWidth:
					return m_LineStyle;
				case Parameters.TextAlignment:
					if (CurrentTool == Shape.Shapes.FreeText)
						return m_TextStyleFreeAlignment;
					return m_TextStyle;
				case Parameters.TextColour:
				case Parameters.TextVerticalAlignment:
				case Parameters.FontSize:
				case Parameters.FontStyle:
				case Parameters.FontFace:
					return m_TextStyle;
				case Parameters.ArrowheadEndSize:
				case Parameters.ArrowheadEndType:
					return m_EndArrowhead;
				case Parameters.ArrowheadStartSize:
				case Parameters.ArrowheadStartType:
					return m_StartArrowhead;
				default:
					Debug.Fail("StyleParameterDefaultObject not defined for " + parameter + ", will probably crash...");
					return null;
			}
		}

		internal void DisplayShapeStyles(Shape shape)
		{
			Debug.Assert(shape != null);
			DisplayShapeStyles(new[] { shape });
		}

		private void DisplayShapeStyles(IEnumerable<Shape> shapes)
		{
			// Update the GUI with the style from the given shapes, where the shapes actually implement that style
			// and the value is consistent across all the shapes on the list
			// colShapes cannot be nothing
			bool[] detected = new bool[(int)Parameters.LastStyle + 1];
			bool[] inconsistent = new bool[(int)Parameters.LastStyle + 1]; // true once we have detected conflicting values
			int[] values = new int[(int)Parameters.LastStyle + 1];
			foreach (Shape shape in shapes)
			{
				for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
				{
					Shape.StyleBase style = shape.StyleObjectForParameter(parameter);
					int asInteger = (int)parameter;
					if (style != null)
					{
						if (!detected[asInteger])
						{
							detected[asInteger] = true;
							values[asInteger] = style.ParameterValue(parameter);
						}
						else
						{
							if (values[asInteger] != style.ParameterValue(parameter))
								inconsistent[asInteger] = true;
						}
					}
				}
			}
			inconsistent[(int)Parameters.FontSize] = false;
			// because not displayed, and Smaller/Larger uses this.  If it is not set, they become nonsense.  Better to use a font size from the objects, than some old value

			// Now update the GUI with any values which have been detected and are consistent
			for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
			{
				int asInteger = (int)parameter;
				if (detected[asInteger] && !inconsistent[asInteger])
					m_aDisplayedStyle[asInteger] = values[asInteger];
				Globals.SetApplicable(detected[asInteger], parameter);
			}
			// the events are raised in a separate loop afterwards, because the values we report through ParameterValue sometimes depend
			// on the styling parameters.  So we don't want to report that the first parameter has changed until we have stored any changes to any other parameters
			// which might affect how we report it publicly
			for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
			{
				int asInteger = (int)parameter;
				if (detected[asInteger] && !inconsistent[asInteger])
					Globals.OnParameterChanged(parameter);
			}

		}

		private void DisplayDefaultValues()
		{
			for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
			{
				if (parameter == (Parameters)9 || parameter == (Parameters)10)
					continue;
				int value = StyleParameterDefaultObject(parameter).ParameterValue(parameter);
				if (value != m_aDisplayedStyle[(int)parameter])
				{
					m_aDisplayedStyle[(int)parameter] = value;
					Globals.OnParameterChanged(parameter);
				}
			}
		}

		private void StyleStateChanged()
		{
			// can be called when it is known that the palettes need to be updated
			if (m_Page != null && m_Page.SelectedCount > 0) // page may be null as this can trigger during change document
				DisplayShapeStyles(Shape.FlattenList(m_Page.SelectedShapes, Shape.FlatListPurpose.Style)); // this will also update applicability
			else if (pnlView.OngoingShape != null)
				DisplayShapeStyles(pnlView.OngoingShape);
			else
			{
				// Need to check what is applicable to the current shape
				if ((Shape.GetClass(m_eTool) == Shape.Classes.Real || Shape.GetClass(m_eTool) == Shape.Classes.Activity))
				{
					Shape test = Shape.CreateShape(CurrentTool);
					test.InitialiseFreeStanding();
					for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
					{
						Globals.SetApplicable(test.StyleObjectForParameter(parameter) != null, parameter);
					}
				}
				else
				{
					// Else - with selectors and the like nothing is applicable.
					for (Parameters parameter = Parameters.FirstStyle; parameter <= Parameters.LastStyle; parameter++)
					{
						Globals.SetApplicable(false, parameter);
					}
				}
			}
		}

		public void SetFontAsDefault(Font font)
		{
			m_TextStyle.ApplyFont(font);
		}

		internal void SetArrowheadsNone()
		{
			m_EndArrowhead.Style = Lined.ArrowheadC.Styles.None;
			m_StartArrowhead.Style = Lined.ArrowheadC.Styles.None;
		}

		#endregion

		#region Advanced Panels
		private void AdvancedPanelReflectSelection()
		{
			bool wasFilling = m_Filling;
			m_Filling = true;
			try
			{
				m_Filling = false;
				m_pnlDocumentOutline.ReflectSelection();
			}
			finally
			{
				m_Filling = wasFilling;
			}
		}
		#endregion

		#region Minor control events and some enabling

		private void m_Page_SelectionChanged()
		{
			StyleStateChanged();
			AdvancedPanelReflectSelection();
			Globals.NotifyVerbApplicabilityChanged();
			Globals.NotifyKeyApplicabilityChanged();
			m_CoordEdit.RefillContent();
		}

		#region Snapping

		public void rdoSnapGrid_UserChecked(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Grid);
		}

		public void rdoSnapShape_UserChecked(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Shape);
		}

		public void rdoSnapAngle_UserChecked(object sender, EventArgs e)
		{
			UserChangeSnapMode(Shape.SnapModes.Angle);
		}

		internal void EnableGridSnap()
		{
			if (m_Page == null)
				return;
			if (m_Page.Paper.PaperType == Paper.Papers.Plain && pnlView.SnapMode == Shape.SnapModes.Grid)
				ActualChangeSnapMode(Shape.SnapModes.Off);
			rdoSnapGrid.Enabled = m_Page.Paper.PaperType != Paper.Papers.Plain;
		}

		#endregion

		private void pnlView_DisplayedAreaChanged(RectangleF rctDisplayed)
		{
			ctrPageList.DisplayArea = rctDisplayed;
		}

		private void pnlView_AngleSnapDisplaysMoveChanged()
		{
			if (pnlView.AngleSnapDisplaysMove)
			{
				rdoSnapAngle.Image = AM.AngleSnapMove;
				rdoSnapAngle.LargeImage = AM.AngleSnapMove_48;
			}
			else
			{
				rdoSnapAngle.Image = AM.AngleSnap;
				rdoSnapAngle.LargeImage = AM.AngleSnap_48;
			}
		}

		#region Painting backgrounds

		public void pnlLeft_Resize(object sender, EventArgs e)
		{
			pnlLeft.Invalidate();
		}

		public void pnlToolbar_Resize(object sender, EventArgs e)
		{
			pnlToolbar.Invalidate();
		}

		#endregion

		#endregion

		#region Support menu (including some diagnostics)

		public void mnuSupport_Click(object sender, EventArgs e)
		{
		}

		public void mnuOpenErrorReport_Click(object sender, EventArgs e)
		{
			if (!CheckDiscardCurrent(false))
				return;
			string strFilename = FileDialog.ShowOpen(FileDialog.Context.ErrorReport);
			if (string.IsNullOrEmpty(strFilename))
				return;

			// mostly from LoadDocument
			m_Document = frmShowErrorReport.Display(strFilename);
			Globals.Root.CurrentDocument = m_Document;
			m_Document.Filename = "";

			ActualChangeSnapMode(m_Document.SnapMode);
			DisplayPage(0);
			GC.Collect();
		}


		#endregion

		#region Debug only and diagnostics and error recovery

		public void mnuTest_Click(object sender, EventArgs e)
		{
			//var a = Activities.GetActivitySettings(Activities.SAW6);
			//Document create = (Document)a.Clone(new Mapping());
			//create.Name = "Graphics mode";
			//Globals.Root.AddNewActivity(create);
			//Globals.Root.SaveAllActivityConfigs();
			//Debug.WriteLine(create.ID);

			//var frm = new frmTest();
			//frm.Show();
		}

		private void InvalidState()
		{
			try
			{
				pnlView.ConcludeOngoing(true);
			}
			catch (Exception ex)
			{
				Utilities.LogSubError(ex);
			}
		}

		private void InvalidDocument()
		{
			m_Document = null;
			if (m_Page != null)
				m_Page.SelectionChanged -= this.m_Page_SelectionChanged;
			m_Page = null;
			Globals.Root.ShowMenu();
		}

		public void chkFullDP_CheckedChanged(object sender, EventArgs e)
		{
			if (chkFullDP.Checked)
				Shape.DiagnosticFormat = "0.########";
			else
				Shape.DiagnosticFormat = "0.#";
			if (m_Page != null && m_Page.SelectedCount == 1)
				pnlView_ChangeDiagnostic(m_Page.SelectedShapes[0]);
		}

		public void mnuDisplayDiagnostic_Click(object sender, EventArgs e)
		{
			pnlConstruction.Visible = !pnlConstruction.Visible;
			mnuDisplayDiagnostic.Checked = pnlConstruction.Visible;
		}

		[Conditional("DEBUG")]
		private void pnlView_ChangeDiagnostic(Shape shape)
		{
			if (shape == null || !lblDiagnostic.Visible)
				lblDiagnostic.Text = "";
			else
			{
				StringBuilder strText = new StringBuilder();
				shape.Diagnostic(strText);
				lblDiagnostic.Text = strText.ToString();
			}
		}

		public void pnlConstruction_VisibleChanged(object sender, EventArgs e)
		{
			StaticView.UnrestrictedZoom = pnlConstruction.Visible;
		}

		public void mnuGenerateError_Click(object sender, EventArgs e)
		{
#if DEBUG
			InvalidOperationException x = new InvalidOperationException();
			frmErrorReport.DoErrorReport(x);
#else
			throw new InvalidOperationException();
#endif
		}


		// image finalise does seem to tidy up as long as not within one loop (see :
		// http://blogs.msdn.com/b/tess/archive/2009/02/03/net-memory-leak-to-dispose-or-not-to-dispose-that-s-the-1-gb-question.aspx
		// it seems finalisers don't always run immediately.  However that shouldn't be a problem.  Still a little worried by occasional failures on David's machine


		#endregion

		#region Desktop
		private void mnuSaveDesktop_Click(object sender, EventArgs e)
		{
			Desktop desktop = new Desktop();
			desktop.PopulateFromWindows();
			if (!frmEditDesktop.Display(desktop)) // note can't use document context as that only works with document filter
				return;
			string file = FileDialog.ShowSave(FileDialog.Context.OtherUserDoc, "*.dsk|*.dsk");
			if (!string.IsNullOrEmpty(file))
				desktop.Save(file);
		}

		private void mnuDesktopEdit_Click(object sender, EventArgs e)
		{
			string file = FileDialog.ShowOpen(FileDialog.Context.OtherUserDoc, "*.dsk|*.dsk");
			if (string.IsNullOrEmpty(file))
				return;
			Desktop desktop = Desktop.LoadFrom(file);
			if (!frmEditDesktop.Display(desktop))
				return;
			file = FileDialog.ShowSave(FileDialog.Context.OtherUserDoc, "*.dsk|*.dsk", System.IO.Path.GetFileName(file));
			if (!string.IsNullOrEmpty(file))
				desktop.Save(file);
		}

		#endregion

		#region Info line
		private string m_InfoLeft = "";
		private string m_InfoCoords = "";

		private void pnlView_DisplayShapeInfo(string text)
		{
			m_InfoLeft = text;
			pnlInfo.Invalidate(); // this changes less often so invalidating the lot is no problem
		}

		private void pnlView_DisplayMousePosition(ClickPosition position)
		{
			//"(" + ptTarget.Exact.X.ToString("0.00") + "," + ptTarget.Exact.Y.ToString("0.00") + ")"
			string newText = "";
			if (position == null)
				lblMouseDiagnostic.Text = "";
			else if (m_Page != null && !m_Page.IsDisposed)
			{
				Measure.Units eUnits = (Measure.Units)Globals.Root.CurrentConfig.ReadInteger("Units", (int)Measure.Units.mm);
				float unitSize = Measure.UnitSizeInMM(eUnits);
				string format = Measure.UnitNumberFormat(eUnits);
				newText = "(" + ((position.Exact.X - m_Page.Origin.X) / unitSize).ToString(format) + ", " +
						 (-(position.Exact.Y - m_Page.Origin.Y) / unitSize).ToString(format) + ")";
				// diagnostic area always contains coordinates in millimetres, ignoring user origin
				lblMouseDiagnostic.Text = "(" + position.Exact.X.ToString("0.00") + "," + (-position.Exact.Y).ToString("0.00") + ")" + " [" + m_Page.Count() + "]";
			}
			if (newText == m_InfoCoords)
				return;
			// only invalidate as needed to reduce flicker
			using (Graphics gr = pnlView.CreateGraphics())
			{
				float width = gr.MeasureString(m_InfoCoords, pnlView.Font, 10000).Width;
				width = Math.Max(width, gr.MeasureString(newText, pnlView.Font, 10000).Width);
				pnlInfo.Invalidate(new Rectangle(pnlInfo.ClientSize.Width - (int)width - 10, 0, (int)(width + 12), pnlInfo.Height));
				// does full height and extra X as it is undermeasuring quite badly (or draws slightly to left of this area)
			}
			m_InfoCoords = newText;
		}

		public void pnlInfo_Paint(object sender, PaintEventArgs e)
		{
			if (!string.IsNullOrEmpty(m_InfoCoords))
				e.Graphics.DrawString(m_InfoCoords, pnlInfo.Font, Brushes.Black, new RectangleF(0, 0, pnlInfo.ClientSize.Width, pnlInfo.ClientSize.Height), GUIUtilities.StringFormatCentreRight);
			if (!string.IsNullOrEmpty(m_InfoLeft))
				e.Graphics.DrawString(m_InfoLeft, pnlInfo.Font, Brushes.Black, new RectangleF(0, 0, pnlInfo.ClientSize.Width, pnlInfo.ClientSize.Height), GUIUtilities.StringFormatCentreLeft);
		}


		#endregion

	}
}
