using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;

namespace SAW
{
	public abstract class Sequential : Filled
	{
		// base class for any shape which is drawn by joining up the vertices.  This basically extends the functionality in Lined for
		// shapes which are a series of lines (e.g. not circle).  We don't want all this functionality in Lined
		// because then any Filled shape would inherit this (e.g. circle)
		// the single line does not derive from this because it is not Filled
		// all subtypes should specify FixedVerticesLength (although the actual number might change dynamically e.g. polygon)
		// this implements most of the verbs:
		// Cancel, CompleteRetrospective are probably sufficient implementations
		// Complete just does Float followed by CompleteRetrospective - in most cases this will also be sufficient
		// Float is derived from Lined and just moves the last point in PolyLine style.  Most classes will need to override this, but can call through to the base if there is not yet enough points to make a postulated shape (e.g. in particular when m_DefineVertices = 1).  When overridden Float should set m_bolAcceptable
		// Choose functionality depends on UseBaseline
		// if false, it just adds points.  The derived class will need to override, but might call back through to deal with the early stages
		// if true, it creates a complete set of points once the baseline is fixed
		//... so the only function that definitely needs to be overridden is Float

		// does not override Load/Save/CopyFrom because there is no data in this class
		// caches a graphics path for the shape, and discards as needed.  Unlike other Lined classes this correctly calculates the bounds with thick lines
		// including the sometimes long point generated by thick lines joining at acute angles.  Most other Lined classes don't really need this as
		// they won't have acute angles (eg circular - except perhaps Pies)

		protected bool m_Acceptable = false; // if true Choose will let the shape be completed (only applicable when placing pt2)

		#region Verbs
		public override VerbResult Cancel(EditableView.ClickPosition position)
		{
			// unless overridden in a subclass this will remove one DEFINED vertex
			// and trim the vertex array to contain just the defined ones plus one floating
			// the vertex array may currently contain any number of other postulated ones
			if (this.Status == StatusValues.Complete)
				return VerbResult.Unchanged;
			if (m_DefinedVertices <= 1)
				return VerbResult.Destroyed;
			m_DefinedVertices -= 1;
			SetLength(m_DefinedVertices + 1);
			return VerbResult.Continuing;
		}

		public override VerbResult CompleteRetrospective()
		{
			Debug.Assert(FixedVerticesLength() > 0);
			// if we have enough POSTULATED points to finish then do so
			if (Vertices.Count == FixedVerticesLength())
			{
				if (m_Acceptable == false)
					return VerbResult.Rejected;
				m_DefinedVertices = FixedVerticesLength();
				DiscardPath();
				return VerbResult.Completed;
			}
			return VerbResult.Rejected;
		}

		public override VerbResult Complete(EditableView.ClickPosition position)
		{
			//If Choose(objPosition) = VerbResult.Rejected Then Return VerbResult.Rejected
			Choose(position);
			return CompleteRetrospective();
		}

		public override VerbResult Choose(EditableView.ClickPosition position)
		{
			PointF pt = position.Snapped;
			if (pt.ApproxEqual(LastDefined))
				return VerbResult.Rejected;
			DiscardPath();
			if (!UseBaseline())
			{
				Debug.Assert(Vertices.Count == m_DefinedVertices + 1, "Sequential.Choose is only applicable when there is a single floating vertex  if not UseBaseline - this function should have been overridden");
				FixVertex();
				return VerbResult.Continuing;
			}

			// once we have two points forming a baseline, generate a complete set of points and float to set their initial positions
			if (m_DefinedVertices == 1)
			{
				// baseline now formed
				Vertices[1] = pt;
				SetLength(FixedVerticesLength());
				m_DefinedVertices = 2;
				Float(position); // will set some sort of default position for all of the remaining vertices
				return VerbResult.Continuing;
			}

			// presumably the shape is complete - however reject if trying to place pt2 on pt1
			if (!m_Acceptable)
				return VerbResult.Rejected;
			Float(position);
			m_DefinedVertices = FixedVerticesLength();
			return VerbResult.Completed;
		}

		public override VerbResult Float(EditableView.ClickPosition pt)
		{
			DiscardPath();
			return base.Float(pt);
		}
		#endregion

		#region Information

		protected virtual bool UseBaseline()
		{
			// should return true if the shape needs just an initial line to start generating a complete shape
			return true;
		}

		public override string StatusInformation(bool ongoing)
		{
			if (ongoing)
			{
				// report the length of the floating segment
				if (m_DefinedVertices >= Vertices.Count)
					return ""; // I think this will be called again in a moment once the shape is truly completed
				return Strings.Item("Info_Length") + ": " + Measure.FormatLength(Geometry.DistanceBetween(Vertices[m_DefinedVertices - 1], Vertices[m_DefinedVertices]));
			}
			else
			{
				// otherwise default behaviour is to return the parameter length
				float total = 0;
				for (int index = 0; index <= Vertices.Count - 2; index++)
				{
					total += Geometry.DistanceBetween(Vertices[index], Vertices[index + 1]);
				}
				if (Closed())
					total += Geometry.DistanceBetween(Vertices[Vertices.Count - 1], Vertices[0]);
				if (Closed())
					return Strings.Item("Info_Perimeter") + ": " + Measure.FormatLength(total);
				return Strings.Item("Info_TotalLength") + ": " + Measure.FormatLength(total);
			}
			//Return ""
		}

		public override AllowedActions Allows
		{
			get
			{
				if (!Closed())
					return base.Allows | AllowedActions.Arrowheads | AllowedActions.Tidy;
				return base.Allows | AllowedActions.Tidy;
			}
		}
		#endregion

		#region Miscellaneous coordinate, Drawing and path
		protected override void InternalDraw(Canvas gr, DrawResources resources)
		{
			base.InternalDrawFromPath(gr, resources);
			base.DrawCentre(gr, resources); // can't be done by Lined.InternalDrawFromPath - only implemented in Filled
			if ((Allows & AllowedActions.Arrowheads) > 0)
				base.DrawArrowheads(resources);
		}

		protected override void CreatePath()
		{
			m_Path = GetLinearPath(Vertices, Closed());
		}

		public override List<Target> GenerateTargets(UserSocket floating)
		{
			return base.GenerateTargetsDefault(floating, Closed());
		}

		public override float[] GetRelevantAngles()
		{
			if (Vertices.Count > 8)
				return null; // too many lines to make it meaningful to snap an angle to any one line
			float[] angles = new float[Vertices.Count - (Closed() ? 1 : 2) + 1]; // if closed one for each point, if open one for each point except last; i.e. each point on the beginning of a line
			for (int index = 0; index <= angles.Length - 1; index++)
			{
				angles[index] = Geometry.VectorAngle(Vertices[index], Vertices[(index + 1) % Vertices.Count]);
			}
			return angles;
		}

		public override void DoGrabAngleSnap(GrabMovement move)
		{
			if (move.GrabType == GrabTypes.SingleVertex)
			{
				if (Closed() || move.ShapeIndex > 0 || move.ShapeIndex < Vertices.Count - 1)
				{
					int previous = move.ShapeIndex > 0 ? move.ShapeIndex - 1 : Vertices.Count - 1;
					int next = (move.ShapeIndex + 1) % Vertices.Count;
					move.Current.Snapped = Geometry.AngleSnapFromTwoPoints(move.Current.Exact, Vertices[previous], Vertices[next], false);
				}
				else if (move.ShapeIndex == 0)
				{
					// moving first point unclosed - just snap to pt2
					move.Current.Snapped = Geometry.AngleSnapPoint(move.Current.Exact, Vertices[1]);
				}
				else
				{
					Debug.Assert(move.ShapeIndex == Vertices.Count - 1);
					move.Current.Snapped = Geometry.AngleSnapPoint(move.Current.Exact, Vertices[Vertices.Count - 2]);
				}
			}
			else
			{
				base.DoGrabAngleSnap(move);
			}
		}

		protected override void SetLength(int length)
		{
			base.SetLength(length);
			DiscardPath();
		}

		protected override bool TidyVertices(SnapModes modes, Page page, int last)
		{
			DiscardPath();
			return base.TidyVertices(modes, page, last);
		}

		public override void NotifyStyleChanged(Parameters parameter, int oldValue, int newValue)
		{
			switch (parameter)
			{
				case Parameters.LineWidth:
					m_Bounds = Rectangle.Empty; // cos line width affects bounds
					break;
			}
			base.NotifyStyleChanged(parameter, oldValue, newValue);
		}

		public override List<Socket> GetSockets() => base.DefaultGetSockets(Closed());

		#endregion

		#region Geometry utilities - calls through to things in Geometry using the points as parameters
		protected bool VerticesFormLine(int intFirstIndex)
		{
			// a utility function for base classes - many shapes cannot be drawn if three of the vertices former line (usually the first three)
			return Geometry.PointApproxOnLine(Vertices[intFirstIndex], Vertices[intFirstIndex + 1], Vertices[intFirstIndex + 2]);
		}

		protected int TurnDirection()
		{
			return Geometry.TurnDirection(Vertices[0], Vertices[1], Vertices[2]);
		}
		#endregion

		public override void CopyFrom(Datum other, CopyDepth depth, Mapping mapID)
		{
			base.CopyFrom(other, depth, mapID);
			DiscardPath();
		}

	}
}